<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Dashboard Verification - AWE Player</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }

        h1 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .test-section {
            margin: 20px auto;
            max-width: 1200px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #00ff00;
            border-radius: 8px;
        }

        .control-panel {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 20px;
            background: #222;
            color: #00ff00;
            border: 2px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
            margin: 5px;
        }

        button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        button.active {
            background: #00ff00;
            color: #000;
        }

        .metric-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric-item {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #00ff00;
        }

        .metric-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .metric-value {
            color: #00ffff;
            font-size: 24px;
            font-weight: bold;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-idle { background: #666; }
        .status-testing { background: #ff9800; }
        .status-success { background: #4caf50; }
        .status-error { background: #f44336; }

        #debug-log {
            width: 100%;
            height: 300px;
            background: #111;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            resize: vertical;
            margin-top: 20px;
        }

        .test-results {
            margin: 20px 0;
            padding: 15px;
            background: #111;
            border-radius: 8px;
        }

        .result-item {
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid #333;
            padding-left: 15px;
        }

        .result-item.pass {
            border-left-color: #00ff00;
            color: #00ff00;
        }

        .result-item.fail {
            border-left-color: #ff0000;
            color: #ff0000;
        }

        .result-item.info {
            border-left-color: #00ffff;
            color: #00ffff;
        }
    </style>
</head>
<body>
    <h1>ðŸŽ¯ Performance Dashboard Verification Test</h1>

    <div class="test-section">
        <div class="control-panel">
            <h2 style="color: #00ffff;">Dashboard Integration Test</h2>
            
            <div style="margin-bottom: 20px;">
                <span class="status-indicator status-idle" id="status-indicator"></span>
                <span id="status-text">Ready to test performance dashboard</span>
            </div>

            <button id="test-dashboard">Test Performance Dashboard</button>
            <button id="test-profiler">Test Profiler Integration</button>
            <button id="simulate-load">Simulate CPU Load</button>
            <button id="test-metrics">Test Metrics Collection</button>
            <button id="run-benchmark">Run Benchmark Suite</button>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Real-time Metrics</h2>
            
            <div class="metric-display">
                <div class="metric-item">
                    <div class="metric-label">Frame Time</div>
                    <div class="metric-value" id="frame-time">--</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">FPS</div>
                    <div class="metric-value" id="fps">--</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">Memory Usage</div>
                    <div class="metric-value" id="memory">--</div>
                </div>
                <div class="metric-item">
                    <div class="metric-label">CPU Load</div>
                    <div class="metric-value" id="cpu-load">--</div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Test Results</h2>
            <div class="test-results" id="test-results">
                <div class="result-item info">Ready to test performance dashboard functionality...</div>
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Debug Log</h2>
            <textarea id="debug-log" readonly></textarea>
        </div>
    </div>

    <script>
        // Performance monitoring variables
        let lastFrameTime = performance.now();
        let frameCount = 0;
        let frameTimes = [];
        let isMonitoring = false;
        let monitoringInterval;
        let cpuLoadInterval;

        // Debug logging function
        function addLog(message) {
            const debugLog = document.getElementById('debug-log');
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            debugLog.value += `[${timestamp}] ${message}\n`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // Test result display
        function addResult(message, type = 'info') {
            const resultsDiv = document.getElementById('test-results');
            const resultItem = document.createElement('div');
            resultItem.className = `result-item ${type}`;
            resultItem.textContent = message;
            resultsDiv.appendChild(resultItem);
        }

        // Clear results
        function clearResults() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
        }

        // Update status indicator
        function setStatus(status, message) {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            
            indicator.className = `status-indicator status-${status}`;
            text.textContent = message;
        }

        // Performance monitoring loop
        function updatePerformanceMetrics() {
            const now = performance.now();
            const frameTime = now - lastFrameTime;
            lastFrameTime = now;
            
            frameTimes.push(frameTime);
            if (frameTimes.length > 60) {
                frameTimes.shift(); // Keep last 60 frames
            }
            
            // Calculate average frame time and FPS
            const avgFrameTime = frameTimes.reduce((a, b) => a + b) / frameTimes.length;
            const fps = 1000 / avgFrameTime;
            
            // Update display
            document.getElementById('frame-time').textContent = avgFrameTime.toFixed(2) + 'ms';
            document.getElementById('fps').textContent = fps.toFixed(1);
            
            // Update memory if available
            if (performance.memory) {
                const memUsage = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
                document.getElementById('memory').textContent = memUsage + 'MB';
            }
            
            frameCount++;
            
            if (isMonitoring) {
                requestAnimationFrame(updatePerformanceMetrics);
            }
        }

        // CPU load simulation
        function simulateCPULoad(intensity = 0.5, duration = 1000) {
            const startTime = performance.now();
            let iterations = 0;
            
            const loadLoop = () => {
                const currentTime = performance.now();
                const elapsed = currentTime - startTime;
                
                if (elapsed < duration) {
                    // Do some CPU-intensive work
                    let sum = 0;
                    for (let i = 0; i < intensity * 100000; i++) {
                        sum += Math.sin(i) * Math.cos(i);
                    }
                    
                    iterations++;
                    document.getElementById('cpu-load').textContent = (intensity * 100).toFixed(0) + '%';
                    
                    // Continue the load
                    requestAnimationFrame(loadLoop);
                } else {
                    document.getElementById('cpu-load').textContent = '0%';
                    addLog(`CPU load simulation completed: ${iterations} iterations`);
                }
            };
            
            loadLoop();
        }

        // Test Dashboard Integration
        document.getElementById('test-dashboard').addEventListener('click', async () => {
            clearResults();
            setStatus('testing', 'Testing performance dashboard integration...');
            addLog('Starting performance dashboard integration test');
            
            try {
                // Test 1: Performance API availability
                if (typeof performance !== 'undefined' && performance.now) {
                    addResult('âœ“ Performance API available', 'pass');
                    addLog('Performance API test passed');
                } else {
                    addResult('âœ— Performance API not available', 'fail');
                    addLog('Performance API test failed');
                }
                
                // Test 2: Memory API availability
                if (performance.memory) {
                    addResult('âœ“ Memory measurement API available', 'pass');
                    addLog('Memory API test passed');
                } else {
                    addResult('âš  Memory measurement API not available', 'info');
                    addLog('Memory API not available (expected in some browsers)');
                }
                
                // Test 3: Frame timing measurement
                const frameTimingResults = [];
                for (let i = 0; i < 10; i++) {
                    const start = performance.now();
                    await new Promise(resolve => requestAnimationFrame(resolve));
                    const end = performance.now();
                    frameTimingResults.push(end - start);
                }
                
                const avgFrameTiming = frameTimingResults.reduce((a, b) => a + b) / frameTimingResults.length;
                
                if (avgFrameTiming > 0 && avgFrameTiming < 100) {
                    addResult(`âœ“ Frame timing measurement working (${avgFrameTiming.toFixed(2)}ms avg)`, 'pass');
                    addLog(`Frame timing test passed: ${avgFrameTiming.toFixed(2)}ms average`);
                } else {
                    addResult('âœ— Frame timing measurement issues', 'fail');
                    addLog(`Frame timing test issues: ${avgFrameTiming}ms`);
                }
                
                // Test 4: Metrics collection
                startMetricsCollection();
                
                setStatus('success', 'Performance dashboard test completed');
                addResult('âœ“ Performance dashboard integration test completed', 'pass');
                
            } catch (error) {
                setStatus('error', 'Performance dashboard test failed');
                addResult(`âœ— Dashboard test error: ${error.message}`, 'fail');
                addLog(`Dashboard test error: ${error.message}`);
            }
        });

        // Test Profiler Integration
        document.getElementById('test-profiler').addEventListener('click', async () => {
            clearResults();
            setStatus('testing', 'Testing profiler integration...');
            addLog('Starting profiler integration test');
            
            try {
                // Test profiler marks and measures
                performance.mark('profiler-test-start');
                
                // Simulate some work
                await new Promise(resolve => setTimeout(resolve, 100));
                let sum = 0;
                for (let i = 0; i < 1000000; i++) {
                    sum += Math.random();
                }
                
                performance.mark('profiler-test-end');
                performance.measure('profiler-test-duration', 'profiler-test-start', 'profiler-test-end');
                
                // Check if measure was created
                const measures = performance.getEntriesByType('measure');
                const testMeasure = measures.find(m => m.name === 'profiler-test-duration');
                
                if (testMeasure && testMeasure.duration > 0) {
                    addResult(`âœ“ Profiler marks/measures working (${testMeasure.duration.toFixed(2)}ms)`, 'pass');
                    addLog(`Profiler test passed: ${testMeasure.duration.toFixed(2)}ms duration`);
                } else {
                    addResult('âœ— Profiler marks/measures not working', 'fail');
                    addLog('Profiler test failed: no measure found');
                }
                
                // Clean up
                performance.clearMarks();
                performance.clearMeasures();
                
                setStatus('success', 'Profiler test completed');
                
            } catch (error) {
                setStatus('error', 'Profiler test failed');
                addResult(`âœ— Profiler test error: ${error.message}`, 'fail');
                addLog(`Profiler test error: ${error.message}`);
            }
        });

        // Simulate CPU Load
        document.getElementById('simulate-load').addEventListener('click', () => {
            addLog('Starting CPU load simulation');
            setStatus('testing', 'Simulating CPU load...');
            
            // Simulate increasing load levels
            const loadLevels = [0.2, 0.4, 0.6, 0.8, 1.0];
            let currentLevel = 0;
            
            const runLoadTest = () => {
                if (currentLevel < loadLevels.length) {
                    const level = loadLevels[currentLevel];
                    addLog(`Simulating ${(level * 100)}% CPU load`);
                    
                    simulateCPULoad(level, 2000);
                    currentLevel++;
                    
                    setTimeout(runLoadTest, 2500);
                } else {
                    setStatus('success', 'CPU load simulation completed');
                    addResult('âœ“ CPU load simulation completed', 'pass');
                }
            };
            
            runLoadTest();
        });

        // Test Metrics Collection
        document.getElementById('test-metrics').addEventListener('click', () => {
            clearResults();
            addLog('Testing metrics collection');
            
            if (!isMonitoring) {
                startMetricsCollection();
                addResult('âœ“ Metrics collection started', 'pass');
                
                // Run test for 5 seconds
                setTimeout(() => {
                    stopMetricsCollection();
                    
                    const avgFrameTime = frameTimes.reduce((a, b) => a + b) / frameTimes.length;
                    const fps = 1000 / avgFrameTime;
                    
                    addResult(`âœ“ Collected ${frameTimes.length} frame samples`, 'pass');
                    addResult(`âœ“ Average frame time: ${avgFrameTime.toFixed(2)}ms`, 'info');
                    addResult(`âœ“ Average FPS: ${fps.toFixed(1)}`, 'info');
                    
                    addLog(`Metrics collection completed: ${frameTimes.length} samples`);
                    setStatus('success', 'Metrics collection test completed');
                }, 5000);
                
                setStatus('testing', 'Collecting metrics for 5 seconds...');
            } else {
                stopMetricsCollection();
                addResult('âœ“ Metrics collection stopped', 'pass');
            }
        });

        // Run Benchmark Suite
        document.getElementById('run-benchmark').addEventListener('click', async () => {
            clearResults();
            setStatus('testing', 'Running benchmark suite...');
            addLog('Starting comprehensive benchmark suite');
            
            const benchmarks = [
                { name: 'Frame Rate Stability', fn: () => benchmarkFrameRate() },
                { name: 'Memory Allocation', fn: () => benchmarkMemoryAllocation() },
                { name: 'CPU Intensive Tasks', fn: () => benchmarkCPUTasks() },
                { name: 'DOM Manipulation', fn: () => benchmarkDOMUpdates() }
            ];
            
            let passedBenchmarks = 0;
            
            for (const benchmark of benchmarks) {
                addLog(`Running benchmark: ${benchmark.name}`);
                
                try {
                    const result = await benchmark.fn();
                    if (result.passed) {
                        addResult(`âœ“ ${benchmark.name}: ${result.metric}`, 'pass');
                        passedBenchmarks++;
                    } else {
                        addResult(`âœ— ${benchmark.name}: ${result.metric}`, 'fail');
                    }
                    
                    addLog(`${benchmark.name} completed: ${result.metric}`);
                } catch (error) {
                    addResult(`âœ— ${benchmark.name}: Error`, 'fail');
                    addLog(`${benchmark.name} failed: ${error.message}`);
                }
                
                // Brief pause between benchmarks
                await new Promise(resolve => setTimeout(resolve, 500));
            }
            
            const successRate = (passedBenchmarks / benchmarks.length * 100).toFixed(1);
            addResult(`Benchmark suite completed: ${successRate}% success rate`, 'info');
            
            setStatus('success', `Benchmarks completed (${successRate}% success)`);
            addLog(`Benchmark suite completed: ${passedBenchmarks}/${benchmarks.length} passed`);
        });

        // Benchmark functions
        async function benchmarkFrameRate() {
            const samples = [];
            const duration = 2000;
            const startTime = performance.now();
            
            while (performance.now() - startTime < duration) {
                const frameStart = performance.now();
                await new Promise(resolve => requestAnimationFrame(resolve));
                const frameEnd = performance.now();
                samples.push(frameEnd - frameStart);
            }
            
            const avgFrameTime = samples.reduce((a, b) => a + b) / samples.length;
            const fps = 1000 / avgFrameTime;
            
            return {
                passed: fps >= 30, // 30 FPS minimum
                metric: `${fps.toFixed(1)} FPS (${avgFrameTime.toFixed(2)}ms)`
            };
        }

        async function benchmarkMemoryAllocation() {
            if (!performance.memory) {
                return { passed: true, metric: 'Memory API not available' };
            }
            
            const initialMemory = performance.memory.usedJSHeapSize;
            
            // Create and destroy objects
            const objects = [];
            for (let i = 0; i < 10000; i++) {
                objects.push({ data: new Array(1000).fill(i) });
            }
            
            const peakMemory = performance.memory.usedJSHeapSize;
            objects.length = 0; // Clear references
            
            // Force garbage collection if possible
            if (window.gc) {
                window.gc();
            }
            
            await new Promise(resolve => setTimeout(resolve, 1000));
            const finalMemory = performance.memory.usedJSHeapSize;
            
            const memoryGrowth = (finalMemory - initialMemory) / 1024 / 1024;
            
            return {
                passed: memoryGrowth < 10, // Less than 10MB growth
                metric: `${memoryGrowth.toFixed(1)}MB growth`
            };
        }

        async function benchmarkCPUTasks() {
            const iterations = 1000000;
            const startTime = performance.now();
            
            let sum = 0;
            for (let i = 0; i < iterations; i++) {
                sum += Math.sin(i * 0.001) * Math.cos(i * 0.002);
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            return {
                passed: duration < 1000, // Less than 1 second
                metric: `${duration.toFixed(2)}ms for ${iterations} operations`
            };
        }

        async function benchmarkDOMUpdates() {
            const container = document.createElement('div');
            document.body.appendChild(container);
            
            const startTime = performance.now();
            
            // Create many DOM elements
            for (let i = 0; i < 1000; i++) {
                const element = document.createElement('div');
                element.textContent = `Element ${i}`;
                element.style.backgroundColor = `hsl(${i % 360}, 50%, 50%)`;
                container.appendChild(element);
            }
            
            const endTime = performance.now();
            const duration = endTime - startTime;
            
            // Clean up
            document.body.removeChild(container);
            
            return {
                passed: duration < 500, // Less than 500ms
                metric: `${duration.toFixed(2)}ms for 1000 DOM updates`
            };
        }

        // Metrics collection functions
        function startMetricsCollection() {
            if (isMonitoring) return;
            
            isMonitoring = true;
            frameTimes = [];
            frameCount = 0;
            lastFrameTime = performance.now();
            
            updatePerformanceMetrics();
            addLog('Performance metrics collection started');
        }

        function stopMetricsCollection() {
            isMonitoring = false;
            addLog('Performance metrics collection stopped');
        }

        // Initialize
        addLog('Performance dashboard verification test loaded');
        addLog('Click buttons above to test dashboard functionality');
        
        // Start basic monitoring
        requestAnimationFrame(updatePerformanceMetrics);
    </script>
</body>
</html>