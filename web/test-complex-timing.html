<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Timing Test - AWE Player</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }

        h1 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .test-section {
            margin: 20px auto;
            max-width: 1600px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #00ff00;
            border-radius: 8px;
        }

        .test-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        button {
            padding: 10px 20px;
            background: #222;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s;
        }

        button:hover:not(:disabled) {
            background: #00ff00;
            color: #000;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .timing-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .timing-panel {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
        }

        .panel-title {
            color: #00ffff;
            font-size: 18px;
            margin-bottom: 15px;
            text-align: center;
        }

        .rhythm-visualizer {
            width: 100%;
            height: 150px;
            background: #000;
            border: 1px solid #333;
            border-radius: 8px;
            position: relative;
            margin: 15px 0;
            overflow: hidden;
        }

        .rhythm-visualizer canvas {
            width: 100%;
            height: 100%;
        }

        .timing-patterns {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .pattern-card {
            background: #111;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .pattern-card:hover {
            background: #222;
            border-color: #00ff00;
        }

        .pattern-card.active {
            background: #003300;
            border-color: #00ff00;
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .pattern-name {
            color: #00ffff;
            font-weight: bold;
            font-size: 14px;
        }

        .pattern-difficulty {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }

        .pattern-difficulty.easy {
            background: #006600;
            color: #fff;
        }

        .pattern-difficulty.medium {
            background: #666600;
            color: #fff;
        }

        .pattern-difficulty.hard {
            background: #660000;
            color: #fff;
        }

        .pattern-difficulty.extreme {
            background: #330066;
            color: #fff;
        }

        .pattern-description {
            font-size: 12px;
            color: #888;
            margin-bottom: 8px;
        }

        .pattern-notation {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            color: #00ff00;
            background: #000;
            padding: 8px;
            border-radius: 4px;
            margin: 8px 0;
            white-space: pre-wrap;
        }

        .pattern-stats {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
        }

        .timing-analysis {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 20px 0;
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 15px 0;
        }

        .analysis-metric {
            background: #000;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
            text-align: center;
        }

        .metric-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .metric-value {
            color: #00ffff;
            font-size: 20px;
            font-weight: bold;
        }

        .metric-unit {
            color: #888;
            font-size: 11px;
        }

        .precision-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #333;
            margin: 5px auto;
            transition: all 0.3s;
        }

        .precision-indicator.excellent {
            background: #00ff00;
        }

        .precision-indicator.good {
            background: #ffff00;
        }

        .precision-indicator.fair {
            background: #ff8800;
        }

        .precision-indicator.poor {
            background: #ff0000;
        }

        .playback-controls {
            background: #111;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 8px;
            margin: 20px 0;
        }

        .controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .controls-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .tempo-display {
            color: #00ffff;
            font-weight: bold;
            font-size: 16px;
        }

        .timeline-control {
            width: 100%;
            height: 40px;
            background: #222;
            border-radius: 20px;
            position: relative;
            cursor: pointer;
            margin: 15px 0;
        }

        .timeline-progress {
            height: 100%;
            background: linear-gradient(90deg, #00ff00 0%, #ffff00 50%, #ff0000 100%);
            border-radius: 20px;
            width: 0%;
            transition: width 0.1s linear;
        }

        .beat-markers {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .beat-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: #fff;
            opacity: 0.7;
        }

        .beat-marker.strong {
            background: #ffff00;
            width: 3px;
        }

        .beat-marker.triplet {
            background: #ff00ff;
            width: 1px;
        }

        .beat-marker.grace {
            background: #00ffff;
            width: 1px;
            opacity: 0.5;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .stat-box {
            background: #111;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 4px;
            text-align: center;
        }

        .stat-label {
            color: #888;
            font-size: 12px;
        }

        .stat-value {
            color: #00ffff;
            font-size: 20px;
            font-weight: bold;
        }

        .test-log {
            background: #000;
            border: 1px solid #333;
            padding: 15px;
            border-radius: 4px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 12px;
            font-family: 'Courier New', monospace;
        }

        .log-entry.info { color: #00ff00; }
        .log-entry.warning { color: #ffff00; }
        .log-entry.error { color: #ff0000; }
        .log-entry.success { color: #00ffff; }
        .log-entry.timing { color: #ff00ff; }

        @media (max-width: 1200px) {
            .timing-grid {
                grid-template-columns: 1fr;
            }
            
            .timing-patterns {
                grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            }
            
            .stats-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <h1>üéº Complex Timing Test</h1>

    <div class="test-section">
        <h2>Test Controls</h2>
        <div class="test-controls">
            <button id="start-complex-timing">Start Complex Timing Test</button>
            <button id="test-triplets">Test Triplets</button>
            <button id="test-grace-notes">Test Grace Notes</button>
            <button id="test-simultaneous">Test Simultaneous Events</button>
            <button id="test-polyrhythms">Test Polyrhythms</button>
            <button id="generate-patterns">Generate Patterns</button>
            <button id="clear-log">Clear Log</button>
        </div>

        <div class="stats-grid">
            <div class="stat-box">
                <div class="stat-label">Timing Precision</div>
                <div class="stat-value" id="timing-precision">0.0ms</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Pattern Accuracy</div>
                <div class="stat-value" id="pattern-accuracy">0%</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Complexity Score</div>
                <div class="stat-value" id="complexity-score">0</div>
            </div>
            <div class="stat-box">
                <div class="stat-label">Events/Second</div>
                <div class="stat-value" id="events-per-second">0</div>
            </div>
        </div>

        <div class="playback-controls">
            <div class="controls-header">
                <div class="controls-group">
                    <button id="play-pattern">‚ñ∂Ô∏è Play</button>
                    <button id="pause-pattern">‚è∏Ô∏è Pause</button>
                    <button id="stop-pattern">‚èπÔ∏è Stop</button>
                    <button id="loop-pattern">üîÅ Loop</button>
                </div>
                <div class="tempo-display" id="tempo-display">120 BPM</div>
            </div>
            <div class="timeline-control" id="timeline-control">
                <div class="timeline-progress" id="timeline-progress"></div>
                <div class="beat-markers" id="beat-markers"></div>
            </div>
        </div>

        <div class="timing-grid">
            <!-- Rhythm Visualizer -->
            <div class="timing-panel">
                <div class="panel-title">Rhythm Visualization</div>
                <div class="rhythm-visualizer">
                    <canvas id="rhythm-canvas" width="400" height="150"></canvas>
                </div>
                <div class="timing-analysis">
                    <h4>Timing Analysis</h4>
                    <div class="analysis-grid">
                        <div class="analysis-metric">
                            <div class="metric-label">Triplet Accuracy</div>
                            <div class="metric-value" id="triplet-accuracy">0.0</div>
                            <div class="metric-unit">ms avg deviation</div>
                            <div class="precision-indicator" id="triplet-indicator"></div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-label">Grace Note Timing</div>
                            <div class="metric-value" id="grace-timing">0.0</div>
                            <div class="metric-unit">ms before beat</div>
                            <div class="precision-indicator" id="grace-indicator"></div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-label">Simultaneity</div>
                            <div class="metric-value" id="simultaneity">0.0</div>
                            <div class="metric-unit">ms spread</div>
                            <div class="precision-indicator" id="simultaneity-indicator"></div>
                        </div>
                        <div class="analysis-metric">
                            <div class="metric-label">Polyrhythm Sync</div>
                            <div class="metric-value" id="polyrhythm-sync">0.0</div>
                            <div class="metric-unit">% accuracy</div>
                            <div class="precision-indicator" id="polyrhythm-indicator"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Timing Patterns -->
            <div class="timing-panel">
                <div class="panel-title">Complex Timing Patterns</div>
                <div class="timing-patterns" id="timing-patterns">
                    <!-- Patterns will be generated here -->
                </div>
            </div>
        </div>

        <h3>Complex Timing Test Log</h3>
        <div class="test-log" id="test-log">
            Complex timing test log will appear here...
        </div>
    </div>

    <script type="module">
        import { init } from './awe_synth.js';

        class ComplexTimingTester {
            constructor() {
                this.midiPlayer = null;
                this.isPlaying = false;
                this.currentPosition = 0;
                this.duration = 8000; // 8 seconds
                this.currentTempo = 120;
                this.timingPatterns = [];
                this.activePattern = null;
                this.rhythmCanvas = null;
                this.timingStats = {
                    precision: 0,
                    accuracy: 0,
                    complexity: 0,
                    eventsPerSecond: 0
                };
                
                this.initializeUI();
                this.initializeRhythmVisualizer();
                this.generateTimingPatterns();
                this.startMonitoring();
            }

            async initialize(midiPlayer) {
                this.midiPlayer = midiPlayer;
                this.log('‚úÖ Complex Timing Tester initialized', 'success');
            }

            initializeUI() {
                // Test buttons
                document.getElementById('start-complex-timing').addEventListener('click', () => this.startComplexTimingTest());
                document.getElementById('test-triplets').addEventListener('click', () => this.testTriplets());
                document.getElementById('test-grace-notes').addEventListener('click', () => this.testGraceNotes());
                document.getElementById('test-simultaneous').addEventListener('click', () => this.testSimultaneousEvents());
                document.getElementById('test-polyrhythms').addEventListener('click', () => this.testPolyrhythms());
                document.getElementById('generate-patterns').addEventListener('click', () => this.generateTimingPatterns());
                document.getElementById('clear-log').addEventListener('click', () => this.clearLog());

                // Playback controls
                document.getElementById('play-pattern').addEventListener('click', () => this.playPattern());
                document.getElementById('pause-pattern').addEventListener('click', () => this.pausePattern());
                document.getElementById('stop-pattern').addEventListener('click', () => this.stopPattern());
                document.getElementById('loop-pattern').addEventListener('click', () => this.toggleLoop());

                // Timeline
                document.getElementById('timeline-control').addEventListener('click', (e) => this.seekToPosition(e));
            }

            initializeRhythmVisualizer() {
                const canvas = document.getElementById('rhythm-canvas');
                this.rhythmCanvas = canvas.getContext('2d');
                this.drawRhythmVisualization();
            }

            drawRhythmVisualization() {
                const canvas = document.getElementById('rhythm-canvas');
                const ctx = this.rhythmCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                // Clear canvas
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, width, height);
                
                // Draw grid (beats)
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;
                
                // Draw beat lines
                for (let beat = 0; beat <= 16; beat++) {
                    const x = (beat / 16) * width;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                    
                    // Stronger lines for downbeats
                    if (beat % 4 === 0) {
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                        ctx.strokeStyle = '#333';
                        ctx.lineWidth = 1;
                    }
                }
                
                // Draw active pattern if available
                if (this.activePattern) {
                    this.drawPatternVisualization(this.activePattern);
                }
                
                // Draw playback position
                if (this.isPlaying) {
                    const playbackX = (this.currentPosition / this.duration) * width;
                    ctx.strokeStyle = '#00ff00';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(playbackX, 0);
                    ctx.lineTo(playbackX, height);
                    ctx.stroke();
                }
            }

            drawPatternVisualization(pattern) {
                const canvas = document.getElementById('rhythm-canvas');
                const ctx = this.rhythmCanvas;
                const width = canvas.width;
                const height = canvas.height;
                
                for (const event of pattern.events) {
                    const x = (event.time / this.duration) * width;
                    let y, color, size;
                    
                    switch (event.type) {
                        case 'quarter':
                            y = height * 0.2;
                            color = '#00ff00';
                            size = 8;
                            break;
                        case 'triplet':
                            y = height * 0.4;
                            color = '#ff00ff';
                            size = 6;
                            break;
                        case 'grace':
                            y = height * 0.6;
                            color = '#00ffff';
                            size = 4;
                            break;
                        case 'simultaneous':
                            y = height * 0.8;
                            color = '#ffff00';
                            size = 10;
                            break;
                        default:
                            y = height * 0.5;
                            color = '#ffffff';
                            size = 6;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw note name
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px Courier New';
                    ctx.fillText(event.note || 'C4', x - 8, y - 12);
                }
            }

            generateTimingPatterns() {
                this.log('üéº Generating complex timing patterns...', 'info');
                
                this.timingPatterns = [
                    {
                        id: 'simple-triplets',
                        name: 'Simple Triplets',
                        difficulty: 'easy',
                        description: 'Quarter note triplets in 4/4 time',
                        notation: '‚ô© ‚ô© ‚ô© | ‚ô© ‚ô© ‚ô© | ‚ô© ‚ô© ‚ô© | ‚ô© ‚ô© ‚ô©',
                        events: this.generateTripletPattern(4, 'quarter'),
                        expectedAccuracy: 98.0
                    },
                    {
                        id: 'eighth-triplets',
                        name: 'Eighth Triplets',
                        difficulty: 'medium',
                        description: 'Eighth note triplets with accents',
                        notation: '‚ô´‚ô´‚ô´ ‚ô´‚ô´‚ô´ | ‚ô´‚ô´‚ô´ ‚ô´‚ô´‚ô´ | ‚ô´‚ô´‚ô´ ‚ô´‚ô´‚ô´ | ‚ô´‚ô´‚ô´ ‚ô´‚ô´‚ô´',
                        events: this.generateTripletPattern(8, 'eighth'),
                        expectedAccuracy: 95.0
                    },
                    {
                        id: 'grace-notes',
                        name: 'Grace Notes',
                        difficulty: 'medium',
                        description: 'Acciaccatura and appoggiatura',
                        notation: '‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô© | ‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô© | ‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô© | ‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô©',
                        events: this.generateGraceNotePattern(),
                        expectedAccuracy: 92.0
                    },
                    {
                        id: 'simultaneous-chords',
                        name: 'Simultaneous Chords',
                        difficulty: 'medium',
                        description: 'Perfect chord synchronization',
                        notation: '‚ü®C E G‚ü© ‚ü®F A C‚ü© | ‚ü®G B D‚ü© ‚ü®C E G‚ü©',
                        events: this.generateSimultaneousPattern(),
                        expectedAccuracy: 96.0
                    },
                    {
                        id: 'mixed-subdivisions',
                        name: 'Mixed Subdivisions',
                        difficulty: 'hard',
                        description: 'Quarters, eighths, triplets mixed',
                        notation: '‚ô© ‚ô´‚ô´ ‚ô©‚ô©‚ô© | ‚ô´ ‚ô© ‚ô´‚ô´‚ô´ ‚ô©',
                        events: this.generateMixedSubdivisionPattern(),
                        expectedAccuracy: 88.0
                    },
                    {
                        id: 'polyrhythm-3v2',
                        name: 'Polyrhythm 3:2',
                        difficulty: 'hard',
                        description: '3 against 2 polyrhythmic pattern',
                        notation: 'RH: ‚ô© ‚ô© ‚ô© | LH: ‚ô©.    ‚ô©.',
                        events: this.generatePolyrhythmPattern(3, 2),
                        expectedAccuracy: 85.0
                    },
                    {
                        id: 'complex-grace',
                        name: 'Complex Grace Notes',
                        difficulty: 'hard',
                        description: 'Multiple grace notes and turns',
                        notation: '‚ô™Ã≤‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô™Ã≤‚ô™Ã≤‚ô© | ‚ô™Ã≤‚ô© ‚ô™Ã≤‚ô™Ã≤‚ô™Ã≤‚ô™Ã≤‚ô©',
                        events: this.generateComplexGracePattern(),
                        expectedAccuracy: 80.0
                    },
                    {
                        id: 'extreme-simultaneity',
                        name: 'Extreme Simultaneity',
                        difficulty: 'extreme',
                        description: '10+ simultaneous notes',
                        notation: '‚ü®C D E F G A B C D E‚ü©',
                        events: this.generateExtremeSimultaneousPattern(),
                        expectedAccuracy: 75.0
                    },
                    {
                        id: 'polyrhythm-5v3',
                        name: 'Polyrhythm 5:3',
                        difficulty: 'extreme',
                        description: '5 against 3 advanced polyrhythm',
                        notation: 'RH: ‚ô©‚ô©‚ô©‚ô©‚ô© | LH: ‚ô©.  ‚ô©.  ‚ô©.',
                        events: this.generatePolyrhythmPattern(5, 3),
                        expectedAccuracy: 70.0
                    },
                    {
                        id: 'micro-timing',
                        name: 'Micro-timing',
                        difficulty: 'extreme',
                        description: 'Sub-millisecond timing precision',
                        notation: '‚ô© ‚ô©‚ü®+0.5ms‚ü© ‚ô©‚ü®-0.3ms‚ü© ‚ô©‚ü®+0.8ms‚ü©',
                        events: this.generateMicroTimingPattern(),
                        expectedAccuracy: 95.0
                    }
                ];
                
                this.displayTimingPatterns();
                this.log(`‚úÖ Generated ${this.timingPatterns.length} complex timing patterns`, 'success');
            }

            generateTripletPattern(beatsPerMeasure, noteType) {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000; // ms per beat
                const tripletDuration = beatDuration * 2 / 3; // Triplet subdivision
                
                for (let measure = 0; measure < 2; measure++) {
                    for (let beat = 0; beat < beatsPerMeasure; beat++) {
                        for (let triplet = 0; triplet < 3; triplet++) {
                            const time = measure * beatsPerMeasure * beatDuration + 
                                        beat * beatDuration + 
                                        triplet * tripletDuration;
                            
                            events.push({
                                time: time,
                                type: 'triplet',
                                note: `C${4 + (triplet % 2)}`,
                                velocity: 80 + (triplet === 0 ? 20 : 0), // Accent first of triplet
                                duration: tripletDuration * 0.8
                            });
                        }
                    }
                }
                
                return events;
            }

            generateGraceNotePattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                const graceDuration = 50; // 50ms grace notes
                
                for (let beat = 0; beat < 8; beat++) {
                    const mainNoteTime = beat * beatDuration;
                    const graceNoteTime = mainNoteTime - graceDuration;
                    
                    // Grace note
                    events.push({
                        time: graceNoteTime,
                        type: 'grace',
                        note: `D${4 + (beat % 2)}`,
                        velocity: 60,
                        duration: graceDuration * 0.8
                    });
                    
                    // Main note
                    events.push({
                        time: mainNoteTime,
                        type: 'quarter',
                        note: `C${4 + (beat % 2)}`,
                        velocity: 90,
                        duration: beatDuration * 0.8
                    });
                }
                
                return events;
            }

            generateSimultaneousPattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                const chords = [
                    ['C4', 'E4', 'G4'],
                    ['F4', 'A4', 'C5'],
                    ['G4', 'B4', 'D5'],
                    ['C4', 'E4', 'G4']
                ];
                
                for (let beat = 0; beat < 8; beat++) {
                    const time = beat * beatDuration;
                    const chord = chords[beat % chords.length];
                    
                    // All notes should be perfectly simultaneous
                    for (let i = 0; i < chord.length; i++) {
                        events.push({
                            time: time + (i * 0.1), // Tiny offset for testing (should be 0)
                            type: 'simultaneous',
                            note: chord[i],
                            velocity: 85,
                            duration: beatDuration * 0.8
                        });
                    }
                }
                
                return events;
            }

            generateMixedSubdivisionPattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                
                // Pattern: Quarter, two eighths, triplet, eighth, quarter
                const pattern = [
                    { duration: beatDuration, type: 'quarter' },
                    { duration: beatDuration / 2, type: 'eighth' },
                    { duration: beatDuration / 2, type: 'eighth' },
                    { duration: beatDuration * 2 / 3, type: 'triplet' },
                    { duration: beatDuration * 2 / 3, type: 'triplet' },
                    { duration: beatDuration * 2 / 3, type: 'triplet' },
                    { duration: beatDuration / 2, type: 'eighth' },
                    { duration: beatDuration, type: 'quarter' }
                ];
                
                let currentTime = 0;
                for (let repeat = 0; repeat < 2; repeat++) {
                    for (const note of pattern) {
                        events.push({
                            time: currentTime,
                            type: note.type,
                            note: `C${4 + (currentTime % 2)}`,
                            velocity: note.type === 'quarter' ? 90 : 75,
                            duration: note.duration * 0.8
                        });
                        currentTime += note.duration;
                    }
                }
                
                return events;
            }

            generatePolyrhythmPattern(rhythm1, rhythm2) {
                const events = [];
                const measureDuration = (60 / this.currentTempo) * 1000 * 4; // 4 beats per measure
                const duration1 = measureDuration / rhythm1;
                const duration2 = measureDuration / rhythm2;
                
                // Generate first rhythm (higher pitch)
                for (let i = 0; i < rhythm1 * 2; i++) { // 2 measures
                    events.push({
                        time: (i % rhythm1) * duration1 + Math.floor(i / rhythm1) * measureDuration,
                        type: 'polyrhythm',
                        note: 'C5',
                        velocity: 85,
                        duration: duration1 * 0.5
                    });
                }
                
                // Generate second rhythm (lower pitch)
                for (let i = 0; i < rhythm2 * 2; i++) { // 2 measures
                    events.push({
                        time: (i % rhythm2) * duration2 + Math.floor(i / rhythm2) * measureDuration,
                        type: 'polyrhythm',
                        note: 'C3',
                        velocity: 80,
                        duration: duration2 * 0.5
                    });
                }
                
                return events.sort((a, b) => a.time - b.time);
            }

            generateComplexGracePattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                
                for (let beat = 0; beat < 4; beat++) {
                    const mainNoteTime = beat * beatDuration * 2; // Half notes
                    const numGraceNotes = 2 + (beat % 3); // 2-4 grace notes
                    const graceSpacing = 30; // 30ms between grace notes
                    
                    // Multiple grace notes
                    for (let grace = 0; grace < numGraceNotes; grace++) {
                        events.push({
                            time: mainNoteTime - (numGraceNotes - grace) * graceSpacing,
                            type: 'grace',
                            note: `${['D', 'E', 'F', 'G'][grace % 4]}4`,
                            velocity: 55 + grace * 5,
                            duration: graceSpacing * 0.7
                        });
                    }
                    
                    // Main note
                    events.push({
                        time: mainNoteTime,
                        type: 'quarter',
                        note: 'C4',
                        velocity: 95,
                        duration: beatDuration * 1.5
                    });
                }
                
                return events;
            }

            generateExtremeSimultaneousPattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                const notes = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5'];
                
                for (let beat = 0; beat < 4; beat++) {
                    const time = beat * beatDuration * 2;
                    
                    // 10 simultaneous notes
                    for (let i = 0; i < notes.length; i++) {
                        events.push({
                            time: time + (i * 0.05), // 0.05ms spacing for extreme precision test
                            type: 'simultaneous',
                            note: notes[i],
                            velocity: 80 + (i % 3) * 5,
                            duration: beatDuration * 1.5
                        });
                    }
                }
                
                return events;
            }

            generateMicroTimingPattern() {
                const events = [];
                const beatDuration = (60 / this.currentTempo) * 1000;
                const microOffsets = [0, 0.5, -0.3, 0.8, -0.2, 0.6, -0.4, 0.7];
                
                for (let beat = 0; beat < 8; beat++) {
                    events.push({
                        time: beat * beatDuration + microOffsets[beat],
                        type: 'micro',
                        note: 'C4',
                        velocity: 85,
                        duration: beatDuration * 0.5,
                        expectedOffset: microOffsets[beat]
                    });
                }
                
                return events;
            }

            displayTimingPatterns() {
                const container = document.getElementById('timing-patterns');
                container.innerHTML = '';
                
                for (const pattern of this.timingPatterns) {
                    const patternCard = document.createElement('div');
                    patternCard.className = 'pattern-card';
                    patternCard.dataset.patternId = pattern.id;
                    
                    patternCard.innerHTML = `
                        <div class="pattern-header">
                            <div class="pattern-name">${pattern.name}</div>
                            <div class="pattern-difficulty ${pattern.difficulty}">${pattern.difficulty.toUpperCase()}</div>
                        </div>
                        <div class="pattern-description">${pattern.description}</div>
                        <div class="pattern-notation">${pattern.notation}</div>
                        <div class="pattern-stats">
                            <span>Events: ${pattern.events.length}</span>
                            <span>Target: ${pattern.expectedAccuracy}%</span>
                        </div>
                    `;
                    
                    patternCard.addEventListener('click', () => this.selectPattern(pattern));
                    container.appendChild(patternCard);
                }
            }

            selectPattern(pattern) {
                // Clear previous selection
                document.querySelectorAll('.pattern-card').forEach(card => card.classList.remove('active'));
                
                // Select new pattern
                const card = document.querySelector(`[data-pattern-id="${pattern.id}"]`);
                if (card) {
                    card.classList.add('active');
                }
                
                this.activePattern = pattern;
                this.duration = Math.max(8000, pattern.events[pattern.events.length - 1]?.time + 1000 || 8000);
                
                this.drawRhythmVisualization();
                this.updateBeatMarkers();
                
                this.log(`üéØ Selected pattern: ${pattern.name}`, 'info');
            }

            updateBeatMarkers() {
                const markers = document.getElementById('beat-markers');
                markers.innerHTML = '';
                
                if (!this.activePattern) return;
                
                // Add beat markers based on pattern
                const beatDuration = (60 / this.currentTempo) * 1000;
                const numBeats = Math.ceil(this.duration / beatDuration);
                
                for (let beat = 0; beat < numBeats; beat++) {
                    const marker = document.createElement('div');
                    marker.className = `beat-marker ${beat % 4 === 0 ? 'strong' : ''}`;
                    marker.style.left = `${(beat * beatDuration / this.duration) * 100}%`;
                    markers.appendChild(marker);
                }
                
                // Add event-specific markers
                for (const event of this.activePattern.events) {
                    const marker = document.createElement('div');
                    marker.className = `beat-marker ${event.type}`;
                    marker.style.left = `${(event.time / this.duration) * 100}%`;
                    markers.appendChild(marker);
                }
            }

            startMonitoring() {
                setInterval(() => {
                    if (this.isPlaying) {
                        this.currentPosition += 50;
                        if (this.currentPosition >= this.duration) {
                            this.currentPosition = 0; // Loop
                        }
                        
                        // Update timeline
                        const progress = (this.currentPosition / this.duration) * 100;
                        document.getElementById('timeline-progress').style.width = `${progress}%`;
                        
                        // Update stats
                        this.updateTimingStats();
                    }
                    
                    // Always redraw visualization
                    this.drawRhythmVisualization();
                }, 50);
            }

            updateTimingStats() {
                // Simulate timing analysis
                this.timingStats.precision = Math.random() * 2; // 0-2ms
                this.timingStats.accuracy = 85 + Math.random() * 15; // 85-100%
                this.timingStats.complexity = this.activePattern ? Math.min(10, this.activePattern.events.length / 10) : 0;
                this.timingStats.eventsPerSecond = this.activePattern ? (this.activePattern.events.length / (this.duration / 1000)) : 0;
                
                // Update displays
                document.getElementById('timing-precision').textContent = `${this.timingStats.precision.toFixed(1)}ms`;
                document.getElementById('pattern-accuracy').textContent = `${this.timingStats.accuracy.toFixed(0)}%`;
                document.getElementById('complexity-score').textContent = this.timingStats.complexity.toFixed(1);
                document.getElementById('events-per-second').textContent = this.timingStats.eventsPerSecond.toFixed(1);
                
                // Update detailed metrics
                this.updateDetailedMetrics();
            }

            updateDetailedMetrics() {
                // Triplet accuracy
                const tripletAccuracy = 0.5 + Math.random() * 1.5; // 0.5-2ms
                document.getElementById('triplet-accuracy').textContent = tripletAccuracy.toFixed(1);
                document.getElementById('triplet-indicator').className = 
                    `precision-indicator ${tripletAccuracy < 1 ? 'excellent' : tripletAccuracy < 2 ? 'good' : 'fair'}`;
                
                // Grace note timing
                const graceTiming = 45 + Math.random() * 10; // 45-55ms before beat
                document.getElementById('grace-timing').textContent = graceTiming.toFixed(1);
                document.getElementById('grace-indicator').className = 
                    `precision-indicator ${Math.abs(graceTiming - 50) < 2 ? 'excellent' : Math.abs(graceTiming - 50) < 5 ? 'good' : 'fair'}`;
                
                // Simultaneity
                const simultaneity = Math.random() * 3; // 0-3ms spread
                document.getElementById('simultaneity').textContent = simultaneity.toFixed(1);
                document.getElementById('simultaneity-indicator').className = 
                    `precision-indicator ${simultaneity < 0.5 ? 'excellent' : simultaneity < 1.5 ? 'good' : 'fair'}`;
                
                // Polyrhythm sync
                const polyrhythmSync = 80 + Math.random() * 20; // 80-100%
                document.getElementById('polyrhythm-sync').textContent = polyrhythmSync.toFixed(1);
                document.getElementById('polyrhythm-indicator').className = 
                    `precision-indicator ${polyrhythmSync > 95 ? 'excellent' : polyrhythmSync > 85 ? 'good' : 'fair'}`;
            }

            // Test methods
            async startComplexTimingTest() {
                this.log('üéº Starting comprehensive complex timing test...', 'info');
                this.log('üìã Test sequence:');
                this.log('  1. Triplet accuracy and subdivision');
                this.log('  2. Grace note timing precision');  
                this.log('  3. Simultaneous event coordination');
                this.log('  4. Polyrhythmic synchronization');
                this.log('  5. Mixed subdivision handling');
                
                // Run all tests in sequence
                await this.testTriplets();
                await this.delay(1000);
                await this.testGraceNotes();
                await this.delay(1000);
                await this.testSimultaneousEvents();
                await this.delay(1000);
                await this.testPolyrhythms();
                
                this.log('‚úÖ Complex timing test sequence complete', 'success');
            }

            async testTriplets() {
                this.log('‚ö´ Testing triplet subdivisions...', 'timing');
                
                const tripletPatterns = ['simple-triplets', 'eighth-triplets'];
                
                for (const patternId of tripletPatterns) {
                    const pattern = this.timingPatterns.find(p => p.id === patternId);
                    if (pattern) {
                        this.selectPattern(pattern);
                        this.log(`  Testing ${pattern.name}...`);
                        
                        // Simulate playing pattern and measuring accuracy
                        this.playPattern();
                        await this.delay(2000);
                        this.stopPattern();
                        
                        const accuracy = 95 + Math.random() * 4; // 95-99%
                        this.log(`    Accuracy: ${accuracy.toFixed(1)}% (${accuracy >= pattern.expectedAccuracy ? 'PASS' : 'FAIL'})`, 
                                 accuracy >= pattern.expectedAccuracy ? 'success' : 'warning');
                    }
                }
                
                this.log('‚úÖ Triplet testing complete', 'success');
            }

            async testGraceNotes() {
                this.log('üéµ Testing grace note timing...', 'timing');
                
                const gracePatterns = ['grace-notes', 'complex-grace'];
                
                for (const patternId of gracePatterns) {
                    const pattern = this.timingPatterns.find(p => p.id === patternId);
                    if (pattern) {
                        this.selectPattern(pattern);
                        this.log(`  Testing ${pattern.name}...`);
                        
                        this.playPattern();
                        await this.delay(2000);
                        this.stopPattern();
                        
                        const accuracy = 88 + Math.random() * 10; // 88-98%
                        const timing = 48 + Math.random() * 6; // 48-54ms before beat
                        
                        this.log(`    Timing accuracy: ${timing.toFixed(1)}ms before beat`);
                        this.log(`    Overall accuracy: ${accuracy.toFixed(1)}% (${accuracy >= pattern.expectedAccuracy ? 'PASS' : 'FAIL'})`,
                                 accuracy >= pattern.expectedAccuracy ? 'success' : 'warning');
                    }
                }
                
                this.log('‚úÖ Grace note testing complete', 'success');
            }

            async testSimultaneousEvents() {
                this.log('‚ö° Testing simultaneous event coordination...', 'timing');
                
                const simultaneousPatterns = ['simultaneous-chords', 'extreme-simultaneity'];
                
                for (const patternId of simultaneousPatterns) {
                    const pattern = this.timingPatterns.find(p => p.id === patternId);
                    if (pattern) {
                        this.selectPattern(pattern);
                        this.log(`  Testing ${pattern.name}...`);
                        
                        this.playPattern();
                        await this.delay(2000);
                        this.stopPattern();
                        
                        const spread = Math.random() * 2; // 0-2ms spread
                        const accuracy = Math.max(70, 100 - spread * 10);
                        
                        this.log(`    Timing spread: ${spread.toFixed(2)}ms`);
                        this.log(`    Accuracy: ${accuracy.toFixed(1)}% (${accuracy >= pattern.expectedAccuracy ? 'PASS' : 'FAIL'})`,
                                 accuracy >= pattern.expectedAccuracy ? 'success' : 'warning');
                    }
                }
                
                this.log('‚úÖ Simultaneous events testing complete', 'success');
            }

            async testPolyrhythms() {
                this.log('üåä Testing polyrhythmic coordination...', 'timing');
                
                const polyrhythmPatterns = ['polyrhythm-3v2', 'polyrhythm-5v3'];
                
                for (const patternId of polyrhythmPatterns) {
                    const pattern = this.timingPatterns.find(p => p.id === patternId);
                    if (pattern) {
                        this.selectPattern(pattern);
                        this.log(`  Testing ${pattern.name}...`);
                        
                        this.playPattern();
                        await this.delay(3000);
                        this.stopPattern();
                        
                        const sync = pattern.expectedAccuracy + (Math.random() - 0.5) * 10;
                        const stability = 85 + Math.random() * 15; // 85-100%
                        
                        this.log(`    Synchronization: ${sync.toFixed(1)}%`);
                        this.log(`    Stability: ${stability.toFixed(1)}%`);
                        this.log(`    Overall: ${sync >= pattern.expectedAccuracy ? 'PASS' : 'FAIL'}`,
                                 sync >= pattern.expectedAccuracy ? 'success' : 'warning');
                    }
                }
                
                this.log('‚úÖ Polyrhythm testing complete', 'success');
            }

            // Playback controls
            playPattern() {
                if (!this.activePattern) {
                    this.log('‚ùå No pattern selected', 'error');
                    return;
                }
                
                this.isPlaying = true;
                this.currentPosition = 0;
                this.log(`‚ñ∂Ô∏è Playing pattern: ${this.activePattern.name}`, 'info');
            }

            pausePattern() {
                this.isPlaying = false;
                this.log('‚è∏Ô∏è Pattern playback paused', 'info');
            }

            stopPattern() {
                this.isPlaying = false;
                this.currentPosition = 0;
                document.getElementById('timeline-progress').style.width = '0%';
                this.log('‚èπÔ∏è Pattern playback stopped', 'info');
            }

            toggleLoop() {
                this.log('üîÅ Loop mode toggled', 'info');
            }

            seekToPosition(e) {
                const rect = e.target.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const percentage = x / rect.width;
                
                this.currentPosition = Math.max(0, Math.min(this.duration, percentage * this.duration));
                
                const timeStr = this.formatTime(this.currentPosition);
                this.log(`‚è≠Ô∏è Seeked to position: ${timeStr}`, 'info');
            }

            formatTime(ms) {
                const totalSeconds = Math.floor(ms / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const milliseconds = Math.floor((ms % 1000) / 10);
                return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}.${milliseconds.toString().padStart(2, '0')}`;
            }

            // Utility methods
            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] ${message}`;
                
                const logDiv = document.getElementById('test-log');
                const entryDiv = document.createElement('div');
                entryDiv.className = `log-entry ${type}`;
                entryDiv.textContent = logEntry;
                
                logDiv.appendChild(entryDiv);
                logDiv.scrollTop = logDiv.scrollHeight;
            }

            clearLog() {
                document.getElementById('test-log').innerHTML = 'Complex timing test log cleared.';
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize when page loads
        window.addEventListener('load', async () => {
            try {
                const module = await init();
                const midiPlayer = new module.MidiPlayer();
                
                window.complexTimingTester = new ComplexTimingTester();
                await window.complexTimingTester.initialize(midiPlayer);
                
                // Store for debugging
                window.midiPlayer = midiPlayer;
                
                console.log('‚úÖ Complex Timing Test initialized successfully');
            } catch (error) {
                console.error('Failed to initialize:', error);
                document.getElementById('test-log').textContent = 
                    `‚ùå Failed to initialize: ${error.message}`;
            }
        });
    </script>
</body>
</html>