/**
 * AWE Player - Main Entry Point for Phase 8 Web Audio Integration
 * 
 * Phase 8A Focus: AudioWorklet Integration
 * - Initialize WASM module
 * - Set up AudioWorklet processor
 * - Create basic UI controls
 * - Test MIDI ‚Üí WASM ‚Üí AudioWorklet ‚Üí Audio output pipeline
 */

import { DebugLogger } from './utils/debug-logger.js';

// Create debug logger instance for main application
const logger = new DebugLogger({ componentName: 'Main', enabled: true });

// Status elements
const wasmStatus = document.getElementById('wasm-status') as HTMLElement;
const audioStatus = document.getElementById('audio-status') as HTMLElement;
const workletStatus = document.getElementById('worklet-status') as HTMLElement;

// Control elements
const startAudioBtn = document.getElementById('start-audio') as HTMLButtonElement;
const playTestToneBtn = document.getElementById('play-test-tone') as HTMLButtonElement;
const stopAudioBtn = document.getElementById('stop-audio') as HTMLButtonElement;
const clearLogBtn = document.getElementById('clear-log') as HTMLButtonElement;

// Debug log textarea
const debugLogTextarea = document.getElementById('debug-log') as HTMLTextAreaElement;

// Piano keys for MIDI testing
const pianoKeys = document.querySelectorAll('.piano-key') as NodeListOf<HTMLButtonElement>;

// Global state
let wasmModule: any = null;
let audioContext: AudioContext | null = null;
let midiPlayer: any = null;

/**
 * Initialize the application
 */
async function main(): Promise<void> {
    try {
        logger.log('üöÄ AWE Player starting - Phase 8A Web Audio Integration');
        
        // Step 1: Load WASM module
        await initializeWASM();
        
        // Step 2: Set up UI event handlers
        setupUIHandlers();
        
        // Step 3: Set up debug log updates
        setupDebugLogUpdates();
        
        logger.log('‚úÖ AWE Player initialization complete');
        updateStatus(wasmStatus, 'WASM: Ready', 'success');
        
    } catch (error) {
        logger.log('‚ùå Failed to initialize AWE Player', error);
        updateStatus(wasmStatus, 'WASM: Error', 'error');
        updateStatus(audioStatus, 'Audio: Failed', 'error');
        updateStatus(workletStatus, 'AudioWorklet: Failed', 'error');
    }
}

/**
 * Load and initialize the WASM module
 */
async function initializeWASM(): Promise<void> {
    try {
        logger.log('üì¶ Loading WASM module...');
        
        // Import WASM module (generated by wasm-pack)
        const wasmPkg = await import('./wasm-pkg/awe_synth.js');
        await wasmPkg.default(); // Initialize WASM
        
        wasmModule = wasmPkg;
        
        // Create MidiPlayer instance
        midiPlayer = new wasmModule.MidiPlayer();
        
        logger.log('‚úÖ WASM module loaded successfully');
        logger.log('üéπ MidiPlayer instance created');
        
    } catch (error) {
        throw new Error(`Failed to load WASM module: ${error}`);
    }
}

/**
 * Set up UI event handlers
 */
function setupUIHandlers(): void {
    // Audio control handlers
    startAudioBtn.addEventListener('click', handleStartAudio);
    playTestToneBtn.addEventListener('click', handlePlayTestTone);
    stopAudioBtn.addEventListener('click', handleStopAudio);
    clearLogBtn.addEventListener('click', handleClearLog);
    
    // Piano key handlers for MIDI testing
    pianoKeys.forEach(key => {
        const note = parseInt(key.dataset.note || '60');
        
        key.addEventListener('mousedown', () => handleNoteOn(note, key));
        key.addEventListener('mouseup', () => handleNoteOff(note, key));
        key.addEventListener('mouseleave', () => handleNoteOff(note, key));
        
        // Touch support
        key.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleNoteOn(note, key);
        });
        key.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleNoteOff(note, key);
        });
    });
    
    // Enable audio start button
    startAudioBtn.disabled = false;
}

/**
 * Handle starting the audio context
 */
async function handleStartAudio(): Promise<void> {
    try {
        logger.log('üîä Starting Web Audio Context...');
        
        // Create AudioContext
        audioContext = new AudioContext();
        
        // Resume if needed (browser audio policy)
        if (audioContext.state === 'suspended') {
            await audioContext.resume();
        }
        
        logger.log(`‚úÖ AudioContext started: ${audioContext.sampleRate}Hz`);
        updateStatus(audioStatus, `Audio: ${audioContext.sampleRate}Hz`, 'success');
        
        // Enable other controls
        playTestToneBtn.disabled = false;
        stopAudioBtn.disabled = false;
        startAudioBtn.disabled = true;
        
        // TODO: Phase 8A.4 - Set up AudioWorklet here
        updateStatus(workletStatus, 'AudioWorklet: TODO Phase 8A.4', 'error');
        
    } catch (error) {
        logger.log('‚ùå Failed to start audio context', error);
        updateStatus(audioStatus, 'Audio: Error', 'error');
    }
}

/**
 * Handle playing a test tone (Phase 8A testing)
 */
function handlePlayTestTone(): void {
    if (!midiPlayer) {
        logger.log('‚ùå MidiPlayer not initialized');
        return;
    }
    
    try {
        logger.log('üéµ Playing test tone...');
        
        // Generate a few samples directly from WASM for testing
        const testSamples: number[] = [];
        for (let i = 0; i < 1000; i++) {
            const sample = midiPlayer.play_test_tone();
            testSamples.push(sample);
        }
        
        logger.log(`‚úÖ Generated ${testSamples.length} test samples`);
        logger.log(`üìä Sample range: ${Math.min(...testSamples).toFixed(6)} to ${Math.max(...testSamples).toFixed(6)}`);
        
        // TODO: Phase 8A.5 - Play through AudioWorklet instead of direct WASM call
        
    } catch (error) {
        logger.log('‚ùå Failed to play test tone', error);
    }
}

/**
 * Handle stopping audio
 */
function handleStopAudio(): void {
    if (audioContext) {
        audioContext.close();
        audioContext = null;
        
        logger.log('üîá Audio context stopped');
        updateStatus(audioStatus, 'Audio: Stopped', 'error');
        updateStatus(workletStatus, 'AudioWorklet: Stopped', 'error');
        
        // Reset button states
        startAudioBtn.disabled = false;
        playTestToneBtn.disabled = true;
        stopAudioBtn.disabled = true;
    }
}

/**
 * Handle note on events (MIDI testing)
 */
function handleNoteOn(note: number, keyElement: HTMLButtonElement): void {
    if (!midiPlayer) return;
    
    try {
        // Create MIDI event and queue it
        const midiEvent = new wasmModule.MidiEvent(0, 0, 0x90, note, 100); // Note on, velocity 100
        midiPlayer.queue_midi_event(midiEvent);
        
        // Visual feedback
        keyElement.classList.add('pressed');
        
        logger.log(`üéπ Note ON: ${note} (${getNoteNameFromMIDI(note)})`);
        
    } catch (error) {
        logger.log(`‚ùå Failed to trigger note ${note}`, error);
    }
}

/**
 * Handle note off events (MIDI testing)
 */
function handleNoteOff(note: number, keyElement: HTMLButtonElement): void {
    if (!midiPlayer) return;
    
    try {
        // Create MIDI event and queue it
        const midiEvent = new wasmModule.MidiEvent(0, 0, 0x80, note, 0); // Note off
        midiPlayer.queue_midi_event(midiEvent);
        
        // Visual feedback
        keyElement.classList.remove('pressed');
        
        logger.log(`üéπ Note OFF: ${note} (${getNoteNameFromMIDI(note)})`);
        
    } catch (error) {
        logger.log(`‚ùå Failed to release note ${note}`, error);
    }
}

/**
 * Handle clearing the debug log
 */
function handleClearLog(): void {
    debugLogTextarea.value = '';
    logger.log('üßπ Debug log cleared');
}

/**
 * Set up periodic debug log updates from WASM
 */
function setupDebugLogUpdates(): void {
    setInterval(() => {
        if (midiPlayer) {
            try {
                const wasmLog = midiPlayer.get_debug_log();
                if (wasmLog && wasmLog.trim() !== debugLogTextarea.value.trim()) {
                    debugLogTextarea.value = wasmLog;
                    debugLogTextarea.scrollTop = debugLogTextarea.scrollHeight;
                }
            } catch (error) {
                // Silently ignore errors in log updates
            }
        }
    }, 100); // Update every 100ms
}

/**
 * Update status display
 */
function updateStatus(element: HTMLElement, text: string, type: 'success' | 'error' | 'info'): void {
    element.textContent = text;
    element.className = `status-item ${type}`;
}

/**
 * Convert MIDI note number to note name
 */
function getNoteNameFromMIDI(note: number): string {
    const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const octave = Math.floor(note / 12) - 1;
    const noteName = noteNames[note % 12];
    return `${noteName}${octave}`;
}

// Start the application
main().catch(error => {
    console.error('üí• Fatal error during initialization:', error);
    updateStatus(wasmStatus, 'WASM: Fatal Error', 'error');
});

export { }; // Make this a module