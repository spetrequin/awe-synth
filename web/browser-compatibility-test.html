<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AWE Player - Browser Compatibility Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            color: #4CAF50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 0 0 20px rgba(76, 175, 80, 0.5);
        }
        
        .browser-info {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        
        .info-item {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }
        
        .info-label {
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 5px;
        }
        
        .controls {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            background: #4CAF50;
            border: none;
            color: white;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }
        
        button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(76, 175, 80, 0.3);
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .test-category {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
        }
        
        .category-title {
            font-size: 1.4em;
            font-weight: bold;
            color: #4CAF50;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #333;
        }
        
        .test-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #333;
        }
        
        .test-item:last-child {
            border-bottom: none;
        }
        
        .test-name {
            flex: 1;
            font-weight: 500;
        }
        
        .test-status {
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.9em;
            font-weight: bold;
            min-width: 80px;
            text-align: center;
        }
        
        .status-pending {
            background: #666;
            color: #fff;
        }
        
        .status-testing {
            background: #2196F3;
            color: #fff;
            animation: pulse 1s infinite;
        }
        
        .status-passed {
            background: #4CAF50;
            color: #fff;
        }
        
        .status-failed {
            background: #f44336;
            color: #fff;
        }
        
        .status-warning {
            background: #ff9800;
            color: #fff;
        }
        
        .status-unsupported {
            background: #9C27B0;
            color: #fff;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }
        
        .results-summary {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            display: none;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .summary-item {
            text-align: center;
            padding: 15px;
            background: #222;
            border-radius: 4px;
        }
        
        .summary-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .summary-label {
            font-size: 0.9em;
            color: #999;
        }
        
        .compatibility-score {
            text-align: center;
            font-size: 2.5em;
            font-weight: bold;
            margin: 20px 0;
        }
        
        .score-excellent {
            color: #4CAF50;
        }
        
        .score-good {
            color: #8BC34A;
        }
        
        .score-fair {
            color: #ff9800;
        }
        
        .score-poor {
            color: #f44336;
        }
        
        .test-log {
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 0.9em;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
        
        .feature-support {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
        }
        
        .feature-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: #222;
            border-radius: 4px;
        }
        
        .feature-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 10px;
        }
        
        .supported {
            background: #4CAF50;
        }
        
        .unsupported {
            background: #f44336;
        }
        
        .partial {
            background: #ff9800;
        }
        
        .benchmark-results {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
            display: none;
        }
        
        .benchmark-chart {
            height: 200px;
            background: #111;
            border-radius: 4px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .export-options {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .browser-warning {
            background: rgba(244, 67, 54, 0.1);
            border: 1px solid #f44336;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
        }
        
        .warning-icon {
            color: #f44336;
            font-size: 1.2em;
            margin-right: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üåê AWE Player Browser Compatibility Test</h1>
        
        <div class="browser-warning" id="browser-warning">
            <span class="warning-icon">‚ö†Ô∏è</span>
            <strong>Compatibility Issue Detected:</strong>
            <span id="warning-message">This browser may have limited support for some features.</span>
        </div>
        
        <div class="browser-info">
            <div class="info-item">
                <div class="info-label">Browser</div>
                <div id="browser-name">Detecting...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Version</div>
                <div id="browser-version">Detecting...</div>
            </div>
            <div class="info-item">
                <div class="info-label">Platform</div>
                <div id="platform">Detecting...</div>
            </div>
            <div class="info-item">
                <div class="info-label">User Agent</div>
                <div id="user-agent" style="font-size: 0.8em;">Detecting...</div>
            </div>
        </div>
        
        <div class="feature-support">
            <h3>üîß Core Feature Support</h3>
            <div class="feature-grid" id="feature-grid">
                <!-- Features will be populated by JavaScript -->
            </div>
        </div>
        
        <div class="controls">
            <button id="run-all-tests">Run All Tests</button>
            <button id="run-critical-tests">Run Critical Tests</button>
            <button id="run-performance-tests">Run Performance Tests</button>
            <button id="export-results">Export Results</button>
            <button id="clear-results">Clear Results</button>
        </div>
        
        <div class="results-summary" id="results-summary">
            <h3>üìä Test Results Summary</h3>
            <div class="summary-grid">
                <div class="summary-item">
                    <div class="summary-value" id="total-tests">0</div>
                    <div class="summary-label">Total Tests</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value status-passed" id="passed-tests">0</div>
                    <div class="summary-label">Passed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value status-warning" id="warning-tests">0</div>
                    <div class="summary-label">Warnings</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value status-failed" id="failed-tests">0</div>
                    <div class="summary-label">Failed</div>
                </div>
                <div class="summary-item">
                    <div class="summary-value status-unsupported" id="unsupported-tests">0</div>
                    <div class="summary-label">Unsupported</div>
                </div>
            </div>
            
            <div class="compatibility-score" id="compatibility-score">
                Calculating...
            </div>
        </div>
        
        <div class="test-grid">
            <div class="test-category">
                <div class="category-title">üß± Core WebAssembly Support</div>
                <div class="test-item">
                    <div class="test-name">WebAssembly.instantiate</div>
                    <div class="test-status status-pending" data-test="wasm-instantiate">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">WebAssembly.Memory</div>
                    <div class="test-status status-pending" data-test="wasm-memory">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">WebAssembly.Table</div>
                    <div class="test-status status-pending" data-test="wasm-table">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">WASM ES6 Module Import</div>
                    <div class="test-status status-pending" data-test="wasm-module">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">WASM SIMD Support</div>
                    <div class="test-status status-pending" data-test="wasm-simd">PENDING</div>
                </div>
            </div>
            
            <div class="test-category">
                <div class="category-title">üéµ Web Audio API</div>
                <div class="test-item">
                    <div class="test-name">AudioContext</div>
                    <div class="test-status status-pending" data-test="audio-context">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">AudioWorklet</div>
                    <div class="test-status status-pending" data-test="audio-worklet">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">OfflineAudioContext</div>
                    <div class="test-status status-pending" data-test="offline-audio">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">Audio Parameter Automation</div>
                    <div class="test-status status-pending" data-test="audio-automation">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">High Sample Rate Support</div>
                    <div class="test-status status-pending" data-test="high-sample-rate">PENDING</div>
                </div>
            </div>
            
            <div class="test-category">
                <div class="category-title">üéπ MIDI Support</div>
                <div class="test-item">
                    <div class="test-name">WebMIDI API</div>
                    <div class="test-status status-pending" data-test="webmidi">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">MIDI Device Access</div>
                    <div class="test-status status-pending" data-test="midi-access">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">MIDI Input/Output</div>
                    <div class="test-status status-pending" data-test="midi-io">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">MIDI Timing Precision</div>
                    <div class="test-status status-pending" data-test="midi-timing">PENDING</div>
                </div>
            </div>
            
            <div class="test-category">
                <div class="category-title">üìÅ File System Access</div>
                <div class="test-item">
                    <div class="test-name">File API</div>
                    <div class="test-status status-pending" data-test="file-api">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">Drag & Drop</div>
                    <div class="test-status status-pending" data-test="drag-drop">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">Large File Support</div>
                    <div class="test-status status-pending" data-test="large-files">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">Binary File Processing</div>
                    <div class="test-status status-pending" data-test="binary-files">PENDING</div>
                </div>
            </div>
            
            <div class="test-category">
                <div class="category-title">‚ö° Performance Features</div>
                <div class="test-item">
                    <div class="test-name">SharedArrayBuffer</div>
                    <div class="test-status status-pending" data-test="shared-array-buffer">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">OffscreenCanvas</div>
                    <div class="test-status status-pending" data-test="offscreen-canvas">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">Performance Observer</div>
                    <div class="test-status status-pending" data-test="performance-observer">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">High-Resolution Timer</div>
                    <div class="test-status status-pending" data-test="high-res-timer">PENDING</div>
                </div>
            </div>
            
            <div class="test-category">
                <div class="category-title">üé® UI/Graphics Support</div>
                <div class="test-item">
                    <div class="test-name">Canvas 2D</div>
                    <div class="test-status status-pending" data-test="canvas-2d">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">CSS Animations</div>
                    <div class="test-status status-pending" data-test="css-animations">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">RequestAnimationFrame</div>
                    <div class="test-status status-pending" data-test="raf">PENDING</div>
                </div>
                <div class="test-item">
                    <div class="test-name">CSS Grid Layout</div>
                    <div class="test-status status-pending" data-test="css-grid">PENDING</div>
                </div>
            </div>
        </div>
        
        <div class="benchmark-results" id="benchmark-results">
            <h3>üìà Performance Benchmarks</h3>
            <div id="benchmark-charts">
                <!-- Charts will be generated by JavaScript -->
            </div>
        </div>
        
        <div class="test-log" id="test-log"></div>
    </div>
    
    <script type="module">
        class BrowserCompatibilityTester {
            constructor() {
                this.results = {};
                this.testQueue = [];
                this.isRunning = false;
                this.log = [];
                
                this.features = {
                    'WebAssembly': () => typeof WebAssembly !== 'undefined',
                    'AudioContext': () => typeof AudioContext !== 'undefined' || typeof webkitAudioContext !== 'undefined',
                    'AudioWorklet': () => typeof AudioWorklet !== 'undefined',
                    'WebMIDI': () => typeof navigator.requestMIDIAccess !== 'undefined',
                    'ES6 Modules': () => 'noModule' in HTMLScriptElement.prototype,
                    'SharedArrayBuffer': () => typeof SharedArrayBuffer !== 'undefined',
                    'OffscreenCanvas': () => typeof OffscreenCanvas !== 'undefined',
                    'File API': () => typeof File !== 'undefined' && typeof FileReader !== 'undefined',
                    'Performance Observer': () => typeof PerformanceObserver !== 'undefined',
                    'High Resolution Time': () => typeof performance.now !== 'undefined',
                    'Canvas 2D': () => {
                        const canvas = document.createElement('canvas');
                        return !!(canvas.getContext && canvas.getContext('2d'));
                    },
                    'CSS Grid': () => CSS.supports('display', 'grid'),
                    'CSS Animations': () => 'animation' in document.documentElement.style,
                    'Drag & Drop': () => 'draggable' in document.createElement('div'),
                    'Request Animation Frame': () => typeof requestAnimationFrame !== 'undefined'
                };
                
                this.browserInfo = this.detectBrowser();
                this.initializeUI();
            }
            
            detectBrowser() {
                const ua = navigator.userAgent;
                const platform = navigator.platform || 'Unknown';
                
                let browser = 'Unknown';
                let version = 'Unknown';
                
                // Chrome
                if (ua.includes('Chrome') && !ua.includes('Edg')) {
                    browser = 'Chrome';
                    version = ua.match(/Chrome\/([0-9.]+)/)?.[1] || 'Unknown';
                }
                // Firefox
                else if (ua.includes('Firefox')) {
                    browser = 'Firefox';
                    version = ua.match(/Firefox\/([0-9.]+)/)?.[1] || 'Unknown';
                }
                // Safari
                else if (ua.includes('Safari') && !ua.includes('Chrome')) {
                    browser = 'Safari';
                    version = ua.match(/Version\/([0-9.]+)/)?.[1] || 'Unknown';
                }
                // Edge
                else if (ua.includes('Edg')) {
                    browser = 'Edge';
                    version = ua.match(/Edg\/([0-9.]+)/)?.[1] || 'Unknown';
                }
                
                return { browser, version, platform, userAgent: ua };
            }
            
            initializeUI() {
                // Update browser info
                document.getElementById('browser-name').textContent = this.browserInfo.browser;
                document.getElementById('browser-version').textContent = this.browserInfo.version;
                document.getElementById('platform').textContent = this.browserInfo.platform;
                document.getElementById('user-agent').textContent = this.browserInfo.userAgent;
                
                // Check for known compatibility issues
                this.checkBrowserWarnings();
                
                // Populate feature grid
                this.populateFeatureGrid();
                
                // Set up event handlers
                this.setupEventHandlers();
                
                // Auto-run feature detection
                this.runFeatureDetection();
            }
            
            checkBrowserWarnings() {
                const warnings = [];
                
                // Check for known issues
                if (this.browserInfo.browser === 'Safari' && parseFloat(this.browserInfo.version) < 14) {
                    warnings.push('Safari versions below 14 may have AudioWorklet issues');
                }
                
                if (this.browserInfo.browser === 'Firefox' && parseFloat(this.browserInfo.version) < 76) {
                    warnings.push('Firefox versions below 76 may have WebMIDI limitations');
                }
                
                if (this.browserInfo.browser === 'Edge' && parseFloat(this.browserInfo.version) < 79) {
                    warnings.push('Legacy Edge may have WebAssembly performance issues');
                }
                
                if (!this.features['SharedArrayBuffer']()) {
                    warnings.push('SharedArrayBuffer not available - this may impact performance');
                }
                
                if (warnings.length > 0) {
                    const warningEl = document.getElementById('browser-warning');
                    const messageEl = document.getElementById('warning-message');
                    messageEl.textContent = warnings.join('. ');
                    warningEl.style.display = 'block';
                }
            }
            
            populateFeatureGrid() {
                const grid = document.getElementById('feature-grid');
                
                for (const [name, test] of Object.entries(this.features)) {
                    const item = document.createElement('div');
                    item.className = 'feature-item';
                    
                    const isSupported = test();
                    const indicator = isSupported ? 'supported' : 'unsupported';
                    
                    item.innerHTML = `
                        <span>${name}</span>
                        <div class="feature-indicator ${indicator}"></div>
                    `;
                    
                    grid.appendChild(item);
                }
            }
            
            setupEventHandlers() {
                document.getElementById('run-all-tests').addEventListener('click', () => {
                    this.runAllTests();
                });
                
                document.getElementById('run-critical-tests').addEventListener('click', () => {
                    this.runCriticalTests();
                });
                
                document.getElementById('run-performance-tests').addEventListener('click', () => {
                    this.runPerformanceTests();
                });
                
                document.getElementById('export-results').addEventListener('click', () => {
                    this.exportResults();
                });
                
                document.getElementById('clear-results').addEventListener('click', () => {
                    this.clearResults();
                });
            }
            
            runFeatureDetection() {
                this.log('üîç Running feature detection...');
                
                // This happens immediately and doesn't need async testing
                this.log('‚úÖ Feature detection complete');
            }
            
            async runAllTests() {
                if (this.isRunning) return;
                
                this.log('üöÄ Starting comprehensive browser compatibility tests...');
                this.isRunning = true;
                this.disableButtons();
                
                const tests = [
                    ...this.getCoreTests(),
                    ...this.getAudioTests(),
                    ...this.getMIDITests(),
                    ...this.getFileTests(),
                    ...this.getPerformanceTests(),
                    ...this.getUITests()
                ];
                
                await this.runTests(tests);
                
                this.enableButtons();
                this.isRunning = false;
                this.showResults();
                this.log('üèÅ All tests completed');
            }
            
            async runCriticalTests() {
                if (this.isRunning) return;
                
                this.log('üéØ Running critical compatibility tests...');
                this.isRunning = true;
                this.disableButtons();
                
                const tests = [
                    ...this.getCoreTests(),
                    ...this.getAudioTests().slice(0, 3) // First 3 audio tests
                ];
                
                await this.runTests(tests);
                
                this.enableButtons();
                this.isRunning = false;
                this.showResults();
                this.log('üèÅ Critical tests completed');
            }
            
            async runPerformanceTests() {
                if (this.isRunning) return;
                
                this.log('‚ö° Running performance compatibility tests...');
                this.isRunning = true;
                this.disableButtons();
                
                const tests = this.getPerformanceTests();
                await this.runTests(tests);
                
                // Run benchmarks
                await this.runBenchmarks();
                
                this.enableButtons();
                this.isRunning = false;
                this.showResults();
                this.log('üèÅ Performance tests completed');
            }
            
            getCoreTests() {
                return [
                    {
                        name: 'wasm-instantiate',
                        test: () => this.testWASMInstantiate(),
                        critical: true
                    },
                    {
                        name: 'wasm-memory',
                        test: () => this.testWASMMemory(),
                        critical: true
                    },
                    {
                        name: 'wasm-table',
                        test: () => this.testWASMTable(),
                        critical: false
                    },
                    {
                        name: 'wasm-module',
                        test: () => this.testWASMModule(),
                        critical: true
                    },
                    {
                        name: 'wasm-simd',
                        test: () => this.testWASMSIMD(),
                        critical: false
                    }
                ];
            }
            
            getAudioTests() {
                return [
                    {
                        name: 'audio-context',
                        test: () => this.testAudioContext(),
                        critical: true
                    },
                    {
                        name: 'audio-worklet',
                        test: () => this.testAudioWorklet(),
                        critical: true
                    },
                    {
                        name: 'offline-audio',
                        test: () => this.testOfflineAudio(),
                        critical: false
                    },
                    {
                        name: 'audio-automation',
                        test: () => this.testAudioAutomation(),
                        critical: false
                    },
                    {
                        name: 'high-sample-rate',
                        test: () => this.testHighSampleRate(),
                        critical: false
                    }
                ];
            }
            
            getMIDITests() {
                return [
                    {
                        name: 'webmidi',
                        test: () => this.testWebMIDI(),
                        critical: false
                    },
                    {
                        name: 'midi-access',
                        test: () => this.testMIDIAccess(),
                        critical: false
                    },
                    {
                        name: 'midi-io',
                        test: () => this.testMIDIIO(),
                        critical: false
                    },
                    {
                        name: 'midi-timing',
                        test: () => this.testMIDITiming(),
                        critical: false
                    }
                ];
            }
            
            getFileTests() {
                return [
                    {
                        name: 'file-api',
                        test: () => this.testFileAPI(),
                        critical: true
                    },
                    {
                        name: 'drag-drop',
                        test: () => this.testDragDrop(),
                        critical: false
                    },
                    {
                        name: 'large-files',
                        test: () => this.testLargeFiles(),
                        critical: false
                    },
                    {
                        name: 'binary-files',
                        test: () => this.testBinaryFiles(),
                        critical: true
                    }
                ];
            }
            
            getPerformanceTests() {
                return [
                    {
                        name: 'shared-array-buffer',
                        test: () => this.testSharedArrayBuffer(),
                        critical: false
                    },
                    {
                        name: 'offscreen-canvas',
                        test: () => this.testOffscreenCanvas(),
                        critical: false
                    },
                    {
                        name: 'performance-observer',
                        test: () => this.testPerformanceObserver(),
                        critical: false
                    },
                    {
                        name: 'high-res-timer',
                        test: () => this.testHighResTimer(),
                        critical: true
                    }
                ];
            }
            
            getUITests() {
                return [
                    {
                        name: 'canvas-2d',
                        test: () => this.testCanvas2D(),
                        critical: true
                    },
                    {
                        name: 'css-animations',
                        test: () => this.testCSSAnimations(),
                        critical: false
                    },
                    {
                        name: 'raf',
                        test: () => this.testRequestAnimationFrame(),
                        critical: true
                    },
                    {
                        name: 'css-grid',
                        test: () => this.testCSSGrid(),
                        critical: false
                    }
                ];
            }
            
            async runTests(tests) {
                for (const test of tests) {
                    this.setTestStatus(test.name, 'testing');
                    
                    try {
                        const result = await test.test();
                        this.results[test.name] = result;
                        this.setTestStatus(test.name, result.status);
                        
                        if (result.message) {
                            this.log(`${test.name}: ${result.message}`);
                        }
                    } catch (error) {
                        this.results[test.name] = {
                            status: 'failed',
                            error: error.message
                        };
                        this.setTestStatus(test.name, 'failed');
                        this.log(`${test.name}: ERROR - ${error.message}`);
                    }
                    
                    // Small delay between tests
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
            }
            
            setTestStatus(testName, status) {
                const element = document.querySelector(`[data-test="${testName}"]`);
                if (element) {
                    element.className = `test-status status-${status}`;
                    element.textContent = status.toUpperCase();
                }
            }
            
            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logMessage = `[${timestamp}] ${message}`;
                this.log.push(logMessage);
                
                const logElement = document.getElementById('test-log');
                logElement.textContent = this.log.join('\\n');
                logElement.scrollTop = logElement.scrollHeight;
            }
            
            disableButtons() {
                const buttons = document.querySelectorAll('button');
                buttons.forEach(btn => btn.disabled = true);
            }
            
            enableButtons() {
                const buttons = document.querySelectorAll('button');
                buttons.forEach(btn => btn.disabled = false);
            }
            
            showResults() {
                const summary = this.calculateSummary();
                this.updateSummaryDisplay(summary);
                document.getElementById('results-summary').style.display = 'block';
            }
            
            calculateSummary() {
                const summary = {
                    total: 0,
                    passed: 0,
                    warning: 0,
                    failed: 0,
                    unsupported: 0
                };
                
                for (const result of Object.values(this.results)) {
                    summary.total++;
                    summary[result.status]++;
                }
                
                const score = Math.round((summary.passed / summary.total) * 100) || 0;
                
                return { ...summary, score };
            }
            
            updateSummaryDisplay(summary) {
                document.getElementById('total-tests').textContent = summary.total;
                document.getElementById('passed-tests').textContent = summary.passed;
                document.getElementById('warning-tests').textContent = summary.warning;
                document.getElementById('failed-tests').textContent = summary.failed;
                document.getElementById('unsupported-tests').textContent = summary.unsupported;
                
                const scoreElement = document.getElementById('compatibility-score');
                scoreElement.textContent = `${summary.score}% Compatible`;
                
                // Update score color
                scoreElement.className = 'compatibility-score';
                if (summary.score >= 90) {
                    scoreElement.classList.add('score-excellent');
                } else if (summary.score >= 75) {
                    scoreElement.classList.add('score-good');
                } else if (summary.score >= 50) {
                    scoreElement.classList.add('score-fair');
                } else {
                    scoreElement.classList.add('score-poor');
                }
            }
            
            // Test implementations
            
            async testWASMInstantiate() {
                try {
                    // Try to create a minimal WASM module
                    const wasmCode = new Uint8Array([
                        0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00
                    ]);
                    
                    const module = await WebAssembly.instantiate(wasmCode);
                    return {
                        status: 'passed',
                        message: 'WebAssembly.instantiate works correctly'
                    };
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `WebAssembly.instantiate failed: ${error.message}`
                    };
                }
            }
            
            async testWASMMemory() {
                try {
                    const memory = new WebAssembly.Memory({ initial: 1 });
                    const buffer = memory.buffer;
                    
                    if (buffer instanceof ArrayBuffer) {
                        return {
                            status: 'passed',
                            message: 'WebAssembly.Memory works correctly'
                        };
                    } else {
                        return {
                            status: 'failed',
                            message: 'WebAssembly.Memory buffer is not ArrayBuffer'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `WebAssembly.Memory failed: ${error.message}`
                    };
                }
            }
            
            async testWASMTable() {
                try {
                    const table = new WebAssembly.Table({
                        initial: 1,
                        element: 'anyfunc'
                    });
                    
                    return {
                        status: 'passed',
                        message: 'WebAssembly.Table works correctly'
                    };
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `WebAssembly.Table failed: ${error.message}`
                    };
                }
            }
            
            async testWASMModule() {
                try {
                    // Test ES6 module import capability
                    if ('noModule' in HTMLScriptElement.prototype) {
                        return {
                            status: 'passed',
                            message: 'ES6 module import supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'ES6 modules not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Module test failed: ${error.message}`
                    };
                }
            }
            
            async testWASMSIMD() {
                try {
                    // SIMD support is hard to test directly, check for WebAssembly.SIMD
                    if (typeof WebAssembly !== 'undefined' && WebAssembly.SIMD) {
                        return {
                            status: 'passed',
                            message: 'WebAssembly SIMD supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'WebAssembly SIMD not available'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'unsupported',
                        message: 'SIMD detection failed'
                    };
                }
            }
            
            async testAudioContext() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    
                    if (!AudioContextClass) {
                        return {
                            status: 'unsupported',
                            message: 'AudioContext not supported'
                        };
                    }
                    
                    const ctx = new AudioContextClass();
                    
                    // Test basic properties
                    if (ctx.sampleRate && ctx.createOscillator) {
                        await ctx.close();
                        return {
                            status: 'passed',
                            message: `AudioContext works (${ctx.sampleRate}Hz)`
                        };
                    } else {
                        return {
                            status: 'failed',
                            message: 'AudioContext missing essential features'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `AudioContext failed: ${error.message}`
                    };
                }
            }
            
            async testAudioWorklet() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    
                    if (!AudioContextClass) {
                        return {
                            status: 'unsupported',
                            message: 'AudioContext not supported'
                        };
                    }
                    
                    const ctx = new AudioContextClass();
                    
                    if (ctx.audioWorklet) {
                        await ctx.close();
                        return {
                            status: 'passed',
                            message: 'AudioWorklet supported'
                        };
                    } else {
                        await ctx.close();
                        return {
                            status: 'unsupported',
                            message: 'AudioWorklet not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `AudioWorklet test failed: ${error.message}`
                    };
                }
            }
            
            async testOfflineAudio() {
                try {
                    const OfflineAudioContextClass = window.OfflineAudioContext || window.webkitOfflineAudioContext;
                    
                    if (!OfflineAudioContextClass) {
                        return {
                            status: 'unsupported',
                            message: 'OfflineAudioContext not supported'
                        };
                    }
                    
                    const ctx = new OfflineAudioContextClass(2, 44100, 44100);
                    const buffer = await ctx.startRendering();
                    
                    if (buffer && buffer.length === 44100) {
                        return {
                            status: 'passed',
                            message: 'OfflineAudioContext works correctly'
                        };
                    } else {
                        return {
                            status: 'failed',
                            message: 'OfflineAudioContext rendering failed'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `OfflineAudioContext failed: ${error.message}`
                    };
                }
            }
            
            async testAudioAutomation() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    const ctx = new AudioContextClass();
                    
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    
                    // Test parameter automation
                    gain.gain.setValueAtTime(0, ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(1, ctx.currentTime + 1);
                    
                    await ctx.close();
                    
                    return {
                        status: 'passed',
                        message: 'Audio parameter automation supported'
                    };
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Audio automation failed: ${error.message}`
                    };
                }
            }
            
            async testHighSampleRate() {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    
                    // Try to create context with high sample rate
                    const ctx = new AudioContextClass({ sampleRate: 96000 });
                    const actualRate = ctx.sampleRate;
                    
                    await ctx.close();
                    
                    if (actualRate >= 88200) {
                        return {
                            status: 'passed',
                            message: `High sample rate supported (${actualRate}Hz)`
                        };
                    } else {
                        return {
                            status: 'warning',
                            message: `Limited to ${actualRate}Hz sample rate`
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `High sample rate test failed: ${error.message}`
                    };
                }
            }
            
            async testWebMIDI() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        return {
                            status: 'unsupported',
                            message: 'WebMIDI API not supported'
                        };
                    }
                    
                    return {
                        status: 'passed',
                        message: 'WebMIDI API available'
                    };
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `WebMIDI test failed: ${error.message}`
                    };
                }
            }
            
            async testMIDIAccess() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        return {
                            status: 'unsupported',
                            message: 'WebMIDI API not supported'
                        };
                    }
                    
                    const access = await navigator.requestMIDIAccess();
                    
                    return {
                        status: 'passed',
                        message: `MIDI access granted (${access.inputs.size} inputs, ${access.outputs.size} outputs)`
                    };
                } catch (error) {
                    return {
                        status: 'warning',
                        message: `MIDI access denied or failed: ${error.message}`
                    };
                }
            }
            
            async testMIDIIO() {
                // This would require actual MIDI devices, so we'll just check API availability
                return this.testMIDIAccess();
            }
            
            async testMIDITiming() {
                try {
                    if (!navigator.requestMIDIAccess) {
                        return {
                            status: 'unsupported',
                            message: 'WebMIDI API not supported'
                        };
                    }
                    
                    // Test high-resolution timestamp support
                    if (typeof performance.now === 'function') {
                        return {
                            status: 'passed',
                            message: 'High-resolution timing available for MIDI'
                        };
                    } else {
                        return {
                            status: 'warning',
                            message: 'Limited timing precision for MIDI'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `MIDI timing test failed: ${error.message}`
                    };
                }
            }
            
            async testFileAPI() {
                try {
                    if (typeof File !== 'undefined' && typeof FileReader !== 'undefined') {
                        // Test FileReader capability
                        const reader = new FileReader();
                        
                        return {
                            status: 'passed',
                            message: 'File API fully supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'File API not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `File API test failed: ${error.message}`
                    };
                }
            }
            
            async testDragDrop() {
                try {
                    const div = document.createElement('div');
                    
                    if ('draggable' in div) {
                        return {
                            status: 'passed',
                            message: 'Drag & Drop API supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'Drag & Drop not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Drag & Drop test failed: ${error.message}`
                    };
                }
            }
            
            async testLargeFiles() {
                try {
                    // Test blob creation with reasonable size
                    const testSize = 50 * 1024 * 1024; // 50MB
                    const blob = new Blob([new ArrayBuffer(testSize)]);
                    
                    if (blob.size === testSize) {
                        return {
                            status: 'passed',
                            message: 'Large file support available'
                        };
                    } else {
                        return {
                            status: 'warning',
                            message: 'Limited large file support'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Large file test failed: ${error.message}`
                    };
                }
            }
            
            async testBinaryFiles() {
                try {
                    // Test ArrayBuffer and TypedArray support
                    const buffer = new ArrayBuffer(1024);
                    const view = new Uint8Array(buffer);
                    view[0] = 255;
                    
                    if (view[0] === 255) {
                        return {
                            status: 'passed',
                            message: 'Binary file processing supported'
                        };
                    } else {
                        return {
                            status: 'failed',
                            message: 'Binary file processing failed'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Binary file test failed: ${error.message}`
                    };
                }
            }
            
            async testSharedArrayBuffer() {
                try {
                    if (typeof SharedArrayBuffer !== 'undefined') {
                        const sab = new SharedArrayBuffer(1024);
                        
                        return {
                            status: 'passed',
                            message: 'SharedArrayBuffer supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'SharedArrayBuffer not available (requires HTTPS + COOP/COEP headers)'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'unsupported',
                        message: `SharedArrayBuffer not available: ${error.message}`
                    };
                }
            }
            
            async testOffscreenCanvas() {
                try {
                    if (typeof OffscreenCanvas !== 'undefined') {
                        const canvas = new OffscreenCanvas(100, 100);
                        const ctx = canvas.getContext('2d');
                        
                        if (ctx) {
                            return {
                                status: 'passed',
                                message: 'OffscreenCanvas supported'
                            };
                        } else {
                            return {
                                status: 'warning',
                                message: 'OffscreenCanvas available but context creation failed'
                            };
                        }
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'OffscreenCanvas not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `OffscreenCanvas test failed: ${error.message}`
                    };
                }
            }
            
            async testPerformanceObserver() {
                try {
                    if (typeof PerformanceObserver !== 'undefined') {
                        return {
                            status: 'passed',
                            message: 'PerformanceObserver supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'PerformanceObserver not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `PerformanceObserver test failed: ${error.message}`
                    };
                }
            }
            
            async testHighResTimer() {
                try {
                    if (typeof performance.now === 'function') {
                        const start = performance.now();
                        const end = performance.now();
                        
                        if (end > start) {
                            return {
                                status: 'passed',
                                message: 'High-resolution timer available'
                            };
                        } else {
                            return {
                                status: 'warning',
                                message: 'Timer precision may be limited'
                            };
                        }
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'High-resolution timer not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `High-resolution timer test failed: ${error.message}`
                    };
                }
            }
            
            async testCanvas2D() {
                try {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    if (ctx) {
                        // Test basic drawing
                        ctx.fillRect(0, 0, 10, 10);
                        
                        return {
                            status: 'passed',
                            message: 'Canvas 2D rendering supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'Canvas 2D not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `Canvas 2D test failed: ${error.message}`
                    };
                }
            }
            
            async testCSSAnimations() {
                try {
                    if ('animation' in document.documentElement.style) {
                        return {
                            status: 'passed',
                            message: 'CSS animations supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'CSS animations not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `CSS animations test failed: ${error.message}`
                    };
                }
            }
            
            async testRequestAnimationFrame() {
                try {
                    if (typeof requestAnimationFrame === 'function') {
                        return new Promise((resolve) => {
                            requestAnimationFrame(() => {
                                resolve({
                                    status: 'passed',
                                    message: 'RequestAnimationFrame works correctly'
                                });
                            });
                        });
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'RequestAnimationFrame not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `RequestAnimationFrame test failed: ${error.message}`
                    };
                }
            }
            
            async testCSSGrid() {
                try {
                    if (CSS.supports('display', 'grid')) {
                        return {
                            status: 'passed',
                            message: 'CSS Grid Layout supported'
                        };
                    } else {
                        return {
                            status: 'unsupported',
                            message: 'CSS Grid Layout not supported'
                        };
                    }
                } catch (error) {
                    return {
                        status: 'failed',
                        message: `CSS Grid test failed: ${error.message}`
                    };
                }
            }
            
            async runBenchmarks() {
                this.log('üìà Running performance benchmarks...');
                
                const benchmarks = {
                    'WASM Call Overhead': () => this.benchmarkWASMCalls(),
                    'Audio Buffer Processing': () => this.benchmarkAudioProcessing(),
                    'Memory Allocation': () => this.benchmarkMemoryAllocation(),
                    'Canvas Rendering': () => this.benchmarkCanvasRendering()
                };
                
                const results = {};
                
                for (const [name, benchmark] of Object.entries(benchmarks)) {
                    try {
                        this.log(`Running ${name} benchmark...`);
                        results[name] = await benchmark();
                    } catch (error) {
                        this.log(`${name} benchmark failed: ${error.message}`);
                        results[name] = { error: error.message };
                    }
                }
                
                this.displayBenchmarkResults(results);
            }
            
            async benchmarkWASMCalls() {
                // Simple JavaScript function call benchmark as baseline
                const iterations = 100000;
                
                const testFunction = () => Math.sqrt(42);
                
                // Warmup
                for (let i = 0; i < 1000; i++) testFunction();
                
                // Benchmark
                const start = performance.now();
                for (let i = 0; i < iterations; i++) {
                    testFunction();
                }
                const elapsed = performance.now() - start;
                
                return {
                    iterations,
                    totalTime: elapsed,
                    avgTime: elapsed / iterations,
                    callsPerSecond: (iterations / elapsed) * 1000
                };
            }
            
            async benchmarkAudioProcessing() {
                // Simulate audio buffer processing
                const bufferSize = 512;
                const iterations = 1000;
                const buffer = new Float32Array(bufferSize);
                
                // Fill with test data
                for (let i = 0; i < bufferSize; i++) {
                    buffer[i] = Math.sin(i * 0.1);
                }
                
                const start = performance.now();
                for (let i = 0; i < iterations; i++) {
                    // Simulate audio processing
                    for (let j = 0; j < bufferSize; j++) {
                        buffer[j] *= 0.5; // Simple gain
                    }
                }
                const elapsed = performance.now() - start;
                
                return {
                    bufferSize,
                    iterations,
                    totalTime: elapsed,
                    buffersPerSecond: (iterations / elapsed) * 1000,
                    samplesPerSecond: (iterations * bufferSize / elapsed) * 1000
                };
            }
            
            async benchmarkMemoryAllocation() {
                const iterations = 1000;
                const arraySize = 1024;
                
                const start = performance.now();
                for (let i = 0; i < iterations; i++) {
                    const array = new Float32Array(arraySize);
                    array[0] = i; // Ensure it's not optimized away
                }
                const elapsed = performance.now() - start;
                
                return {
                    iterations,
                    arraySize,
                    totalTime: elapsed,
                    allocationsPerSecond: (iterations / elapsed) * 1000
                };
            }
            
            async benchmarkCanvasRendering() {
                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 100;
                const ctx = canvas.getContext('2d');
                
                const iterations = 1000;
                
                const start = performance.now();
                for (let i = 0; i < iterations; i++) {
                    ctx.fillStyle = `hsl(${i % 360}, 50%, 50%)`;
                    ctx.fillRect(i % 100, (i * 2) % 100, 10, 10);
                }
                const elapsed = performance.now() - start;
                
                return {
                    iterations,
                    totalTime: elapsed,
                    drawCallsPerSecond: (iterations / elapsed) * 1000
                };
            }
            
            displayBenchmarkResults(results) {
                const container = document.getElementById('benchmark-charts');
                container.innerHTML = '';
                
                for (const [name, data] of Object.entries(results)) {
                    if (data.error) continue;
                    
                    const chart = document.createElement('div');
                    chart.className = 'benchmark-chart';
                    chart.innerHTML = `
                        <h4>${name}</h4>
                        <p>Total Time: ${data.totalTime.toFixed(2)}ms</p>
                        <p>Operations/sec: ${(data.callsPerSecond || data.buffersPerSecond || data.allocationsPerSecond || data.drawCallsPerSecond || 0).toFixed(0)}</p>
                    `;
                    
                    container.appendChild(chart);
                }
                
                document.getElementById('benchmark-results').style.display = 'block';
            }
            
            exportResults() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    browser: this.browserInfo,
                    features: this.features,
                    testResults: this.results,
                    summary: this.calculateSummary(),
                    log: this.log
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                    type: 'application/json'
                });
                
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `awe-player-compatibility-${this.browserInfo.browser}-${Date.now()}.json`;
                a.click();
                
                URL.revokeObjectURL(url);
                
                this.log('üìÅ Results exported to JSON file');
            }
            
            clearResults() {
                this.results = {};
                this.log = [];
                
                // Reset all test statuses
                document.querySelectorAll('.test-status').forEach(element => {
                    element.className = 'test-status status-pending';
                    element.textContent = 'PENDING';
                });
                
                // Hide results
                document.getElementById('results-summary').style.display = 'none';
                document.getElementById('benchmark-results').style.display = 'none';
                
                // Clear log
                document.getElementById('test-log').textContent = '';
                
                this.log('üßπ Results cleared');
            }
        }
        
        // Initialize tester when page loads
        const tester = new BrowserCompatibilityTester();
    </script>
</body>
</html>