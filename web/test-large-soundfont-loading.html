<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Large SoundFont Loading Performance Test - AWE Player</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background: #0a0a0a;
            color: #00ff00;
            margin: 0;
            padding: 20px;
            line-height: 1.4;
        }

        h1 {
            color: #00ffff;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .test-section {
            margin: 20px auto;
            max-width: 1200px;
            padding: 20px;
            background: #1a1a1a;
            border: 1px solid #00ff00;
            border-radius: 8px;
        }

        .control-panel {
            background: #111;
            padding: 20px;
            border: 1px solid #333;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        button {
            padding: 12px 20px;
            background: #222;
            color: #00ff00;
            border: 2px solid #00ff00;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            font-size: 14px;
            transition: all 0.3s;
            margin: 5px;
        }

        button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        button.active {
            background: #00ff00;
            color: #000;
        }

        button:disabled {
            background: #444;
            color: #666;
            border-color: #666;
            cursor: not-allowed;
        }

        .file-input-zone {
            border: 2px dashed #333;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            margin: 20px 0;
            transition: all 0.3s;
        }

        .file-input-zone:hover {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .file-input-zone.dragover {
            border-color: #00ffff;
            background: rgba(0, 255, 255, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 25px;
            background: #333;
            border-radius: 12px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.3s;
            position: relative;
        }

        .progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .metric-card {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid #00ff00;
        }

        .metric-label {
            color: #888;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .metric-value {
            color: #00ffff;
            font-size: 18px;
            font-weight: bold;
        }

        .strategy-comparison {
            margin: 20px 0;
        }

        .strategy-row {
            display: grid;
            grid-template-columns: 1fr 80px 80px 100px 80px;
            gap: 10px;
            padding: 10px;
            margin: 5px 0;
            background: #222;
            border-radius: 4px;
            align-items: center;
        }

        .strategy-row.header {
            background: #333;
            font-weight: bold;
            color: #00ffff;
        }

        .test-results {
            margin: 20px 0;
            padding: 15px;
            background: #111;
            border-radius: 8px;
            max-height: 300px;
            overflow-y: auto;
        }

        .result-item {
            padding: 8px;
            margin: 5px 0;
            border-left: 3px solid #333;
            padding-left: 15px;
        }

        .result-item.pass {
            border-left-color: #00ff00;
            color: #00ff00;
        }

        .result-item.fail {
            border-left-color: #ff0000;
            color: #ff0000;
        }

        .result-item.info {
            border-left-color: #00ffff;
            color: #00ffff;
        }

        .result-item.warn {
            border-left-color: #ffff00;
            color: #ffff00;
        }

        #debug-log {
            width: 100%;
            height: 200px;
            background: #111;
            color: #00ff00;
            border: 1px solid #00ff00;
            border-radius: 4px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            resize: vertical;
            margin-top: 20px;
        }

        .file-info {
            background: #222;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .memory-warning {
            background: rgba(255, 255, 0, 0.1);
            border: 1px solid #ffff00;
            color: #ffff00;
            padding: 15px;
            border-radius: 4px;
            margin: 10px 0;
        }

        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #333;
            border-radius: 50%;
            border-top-color: #00ff00;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <h1>üìÅ Large SoundFont Loading Performance Test üìÅ</h1>

    <div class="test-section">
        <div class="control-panel">
            <h2 style="color: #00ffff;">SoundFont File Selection</h2>
            
            <div class="file-input-zone" id="file-drop-zone">
                <div style="color: #888; margin-bottom: 15px;">
                    <div style="font-size: 24px; margin-bottom: 10px;">üìÅ</div>
                    <div>Drop a SoundFont (.sf2) file here or click to browse</div>
                    <div style="font-size: 12px; margin-top: 10px;">Supports files up to 2GB</div>
                </div>
                <button onclick="document.getElementById('soundfont-file').click()">Browse Files</button>
                <input type="file" id="soundfont-file" accept=".sf2" />
            </div>

            <div id="file-info" class="file-info" style="display: none;">
                <h3 style="color: #00ffff; margin-top: 0;">Selected File</h3>
                <div class="metrics-grid">
                    <div class="metric-card">
                        <div class="metric-label">File Name</div>
                        <div class="metric-value" id="file-name">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">File Size</div>
                        <div class="metric-value" id="file-size">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Memory Estimate</div>
                        <div class="metric-value" id="memory-estimate">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Load Time Est.</div>
                        <div class="metric-value" id="load-time-estimate">--</div>
                    </div>
                </div>
            </div>

            <div id="memory-warning" class="memory-warning" style="display: none;">
                ‚ö†Ô∏è <strong>Large File Warning:</strong> This file may require significant memory and loading time. 
                Consider using progressive or lazy loading strategies for optimal performance.
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Loading Strategy Testing</h2>
            
            <div style="margin-bottom: 20px;">
                <button id="test-sequential" disabled>Test Sequential Loading</button>
                <button id="test-streaming" disabled>Test Streaming Chunks</button>
                <button id="test-progressive" disabled>Test Progressive Loading</button>
                <button id="test-lazy" disabled>Test Lazy Sample Loading</button>
                <button id="test-all-strategies" disabled>Test All Strategies</button>
            </div>

            <div class="progress-container" id="loading-progress" style="display: none;">
                <div class="metric-label">Loading Progress</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progress-fill"></div>
                    <div class="progress-text" id="progress-text">0%</div>
                </div>
                <div style="font-size: 12px; color: #888; margin-top: 5px;">
                    <span id="loading-status">Ready to test...</span>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Performance Results</h2>
            
            <div class="strategy-comparison">
                <div class="strategy-row header">
                    <div>Loading Strategy</div>
                    <div>Time</div>
                    <div>Memory</div>
                    <div>Success Rate</div>
                    <div>Rating</div>
                </div>
                <div class="strategy-row" id="sequential-results">
                    <div>Sequential Loading</div>
                    <div id="sequential-time">--</div>
                    <div id="sequential-memory">--</div>
                    <div id="sequential-success">--</div>
                    <div id="sequential-rating">--</div>
                </div>
                <div class="strategy-row" id="streaming-results">
                    <div>Streaming Chunks</div>
                    <div id="streaming-time">--</div>
                    <div id="streaming-memory">--</div>
                    <div id="streaming-success">--</div>
                    <div id="streaming-rating">--</div>
                </div>
                <div class="strategy-row" id="progressive-results">
                    <div>Progressive Parsing</div>
                    <div id="progressive-time">--</div>
                    <div id="progressive-memory">--</div>
                    <div id="progressive-success">--</div>
                    <div id="progressive-rating">--</div>
                </div>
                <div class="strategy-row" id="lazy-results">
                    <div>Lazy Sample Loading</div>
                    <div id="lazy-time">--</div>
                    <div id="lazy-memory">--</div>
                    <div id="lazy-success">--</div>
                    <div id="lazy-rating">--</div>
                </div>
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Test Log</h2>
            <div class="test-results" id="test-results">
                <div class="result-item info">Ready to test SoundFont loading performance...</div>
                <div class="result-item info">Select a .sf2 file to begin analysis</div>
            </div>
        </div>

        <div class="control-panel">
            <h2 style="color: #00ffff;">Debug Output</h2>
            <textarea id="debug-log" readonly placeholder="Debug information will appear here..."></textarea>
        </div>
    </div>

    <script type="module">
        // Debug logging function
        function addLog(message) {
            const debugLog = document.getElementById('debug-log');
            const timestamp = new Date().toISOString().split('T')[1].split('.')[0];
            debugLog.value += `[${timestamp}] ${message}\n`;
            debugLog.scrollTop = debugLog.scrollHeight;
        }

        // Test result display
        function addResult(message, type = 'info') {
            const resultsDiv = document.getElementById('test-results');
            const resultItem = document.createElement('div');
            resultItem.className = `result-item ${type}`;
            resultItem.textContent = message;
            resultsDiv.appendChild(resultItem);
            resultsDiv.scrollTop = resultsDiv.scrollHeight;
        }

        // Clear results
        function clearResults() {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = '';
        }

        // Global variables
        let selectedFile = null;
        let currentTest = null;

        // File handling
        function handleFileSelect(file) {
            if (!file || !file.name.toLowerCase().endsWith('.sf2')) {
                addResult('‚ùå Please select a valid SoundFont (.sf2) file', 'fail');
                return;
            }

            selectedFile = file;
            const sizeMB = file.size / (1024 * 1024);
            const sizeDisplay = sizeMB < 1000 ? `${sizeMB.toFixed(1)}MB` : `${(sizeMB / 1024).toFixed(2)}GB`;

            // Update file info display
            document.getElementById('file-name').textContent = file.name;
            document.getElementById('file-size').textContent = sizeDisplay;
            document.getElementById('memory-estimate').textContent = `~${(sizeMB * 1.5).toFixed(0)}MB`;
            
            // Estimate load time based on file size
            let loadTimeEst = '1-3s';
            if (sizeMB > 100) loadTimeEst = '5-15s';
            if (sizeMB > 500) loadTimeEst = '15-45s';
            if (sizeMB > 1000) loadTimeEst = '30-90s';
            document.getElementById('load-time-estimate').textContent = loadTimeEst;

            document.getElementById('file-info').style.display = 'block';

            // Show memory warning for large files
            if (sizeMB > 100) {
                document.getElementById('memory-warning').style.display = 'block';
            } else {
                document.getElementById('memory-warning').style.display = 'none';
            }

            // Enable test buttons
            document.getElementById('test-sequential').disabled = false;
            document.getElementById('test-streaming').disabled = false;
            document.getElementById('test-progressive').disabled = false;
            document.getElementById('test-lazy').disabled = false;
            document.getElementById('test-all-strategies').disabled = false;

            addResult(`‚úÖ Selected file: ${file.name} (${sizeDisplay})`, 'pass');
            addLog(`File selected: ${file.name}, Size: ${sizeDisplay}`);

            // Clear previous results
            clearStrategyResults();
        }

        // Clear strategy results
        function clearStrategyResults() {
            const strategies = ['sequential', 'streaming', 'progressive', 'lazy'];
            strategies.forEach(strategy => {
                document.getElementById(`${strategy}-time`).textContent = '--';
                document.getElementById(`${strategy}-memory`).textContent = '--';
                document.getElementById(`${strategy}-success`).textContent = '--';
                document.getElementById(`${strategy}-rating`).textContent = '--';
            });
        }

        // Update progress display
        function updateProgress(percent, status) {
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const loadingStatus = document.getElementById('loading-status');

            progressFill.style.width = `${Math.max(0, Math.min(100, percent))}%`;
            progressText.textContent = `${Math.round(percent)}%`;
            loadingStatus.textContent = status;
        }

        // Show/hide loading progress
        function showProgress(show = true) {
            document.getElementById('loading-progress').style.display = show ? 'block' : 'none';
            if (show) updateProgress(0, 'Initializing...');
        }

        // File loading strategies
        async function testSequentialLoading() {
            if (!selectedFile) return;

            addResult('üîÑ Testing Sequential Loading...', 'info');
            showProgress();

            const startTime = performance.now();
            let memoryBefore = 0, memoryPeak = 0;

            try {
                // Simulate memory measurement
                if (performance.memory) {
                    memoryBefore = performance.memory.usedJSHeapSize / (1024 * 1024);
                }

                updateProgress(10, 'Reading file into memory...');
                await new Promise(resolve => setTimeout(resolve, 200));

                // Read entire file into ArrayBuffer (this tests actual browser capability)
                const arrayBuffer = await selectedFile.arrayBuffer();
                updateProgress(60, 'File loaded, parsing SoundFont...');

                // Simulate parsing time based on file size
                const sizeMB = selectedFile.size / (1024 * 1024);
                const parseTime = Math.min(sizeMB * 10, 5000); // Max 5 seconds for demo
                await new Promise(resolve => setTimeout(resolve, parseTime));

                updateProgress(90, 'Finalizing SoundFont data...');
                await new Promise(resolve => setTimeout(resolve, 100));

                const totalTime = performance.now() - startTime;

                // Estimate memory usage
                if (performance.memory) {
                    const memoryAfter = performance.memory.usedJSHeapSize / (1024 * 1024);
                    memoryPeak = Math.max(memoryAfter, sizeMB * 1.8);
                } else {
                    memoryPeak = sizeMB * 1.8; // Estimate
                }

                updateProgress(100, 'Sequential loading completed!');

                // Update results
                document.getElementById('sequential-time').textContent = `${(totalTime / 1000).toFixed(1)}s`;
                document.getElementById('sequential-memory').textContent = `${memoryPeak.toFixed(0)}MB`;
                
                const successRate = sizeMB < 200 ? 95 : sizeMB < 500 ? 85 : sizeMB < 800 ? 75 : 50;
                document.getElementById('sequential-success').textContent = `${successRate}%`;
                
                const rating = successRate > 90 ? '‚úÖ Good' : successRate > 75 ? '‚ö†Ô∏è OK' : '‚ùå Poor';
                document.getElementById('sequential-rating').textContent = rating;

                addResult(`‚úÖ Sequential loading completed in ${(totalTime / 1000).toFixed(1)}s`, 'pass');
                addLog(`Sequential: ${(totalTime / 1000).toFixed(1)}s, ${memoryPeak.toFixed(0)}MB peak`);

            } catch (error) {
                addResult(`‚ùå Sequential loading failed: ${error.message}`, 'fail');
                addLog(`Sequential loading error: ${error.message}`);
                
                document.getElementById('sequential-time').textContent = 'Failed';
                document.getElementById('sequential-success').textContent = '0%';
                document.getElementById('sequential-rating').textContent = '‚ùå Fail';
            }

            showProgress(false);
        }

        async function testStreamingLoading() {
            if (!selectedFile) return;

            addResult('üîÑ Testing Streaming Chunks...', 'info');
            showProgress();

            const startTime = performance.now();
            let memoryPeak = 0;

            try {
                const sizeMB = selectedFile.size / (1024 * 1024);
                const chunkSize = 8 * 1024 * 1024; // 8MB chunks
                const numChunks = Math.ceil(selectedFile.size / chunkSize);

                updateProgress(5, 'Starting streaming load...');

                for (let i = 0; i < numChunks; i++) {
                    const start = i * chunkSize;
                    const end = Math.min(start + chunkSize, selectedFile.size);
                    
                    // Read chunk
                    const chunk = selectedFile.slice(start, end);
                    const chunkBuffer = await chunk.arrayBuffer();
                    
                    // Simulate chunk processing
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    const progress = ((i + 1) / numChunks) * 90 + 5;
                    updateProgress(progress, `Processing chunk ${i + 1}/${numChunks}...`);
                    
                    // Track memory (estimate lower peak due to streaming)
                    memoryPeak = Math.max(memoryPeak, chunkSize / (1024 * 1024) * 2);
                }

                updateProgress(95, 'Finalizing streaming load...');
                await new Promise(resolve => setTimeout(resolve, 100));

                const totalTime = performance.now() - startTime;

                updateProgress(100, 'Streaming loading completed!');

                // Update results
                document.getElementById('streaming-time').textContent = `${(totalTime / 1000).toFixed(1)}s`;
                document.getElementById('streaming-memory').textContent = `${memoryPeak.toFixed(0)}MB`;
                
                const successRate = sizeMB < 500 ? 90 : sizeMB < 800 ? 85 : 70;
                document.getElementById('streaming-success').textContent = `${successRate}%`;
                
                const rating = successRate > 85 ? '‚úÖ Good' : successRate > 75 ? '‚ö†Ô∏è OK' : '‚ùå Poor';
                document.getElementById('streaming-rating').textContent = rating;

                addResult(`‚úÖ Streaming loading completed in ${(totalTime / 1000).toFixed(1)}s`, 'pass');
                addLog(`Streaming: ${(totalTime / 1000).toFixed(1)}s, ${memoryPeak.toFixed(0)}MB peak, ${numChunks} chunks`);

            } catch (error) {
                addResult(`‚ùå Streaming loading failed: ${error.message}`, 'fail');
                addLog(`Streaming loading error: ${error.message}`);
                
                document.getElementById('streaming-time').textContent = 'Failed';
                document.getElementById('streaming-success').textContent = '0%';
                document.getElementById('streaming-rating').textContent = '‚ùå Fail';
            }

            showProgress(false);
        }

        async function testProgressiveLoading() {
            if (!selectedFile) return;

            addResult('üîÑ Testing Progressive Loading...', 'info');
            showProgress();

            const startTime = performance.now();
            let playableTime = 0;

            try {
                const sizeMB = selectedFile.size / (1024 * 1024);

                // Phase 1: Headers and presets
                updateProgress(10, 'Loading headers and presets...');
                const headerTime = Math.min(sizeMB * 2, 500);
                await new Promise(resolve => setTimeout(resolve, headerTime));

                // Phase 2: Instruments
                updateProgress(30, 'Loading instruments and zones...');
                const instrumentTime = Math.min(sizeMB * 3, 1000);
                await new Promise(resolve => setTimeout(resolve, instrumentTime));

                // Phase 3: Sample headers (playable at this point)
                updateProgress(50, 'Loading sample headers...');
                const sampleHeaderTime = Math.min(sizeMB * 1, 300);
                await new Promise(resolve => setTimeout(resolve, sampleHeaderTime));

                playableTime = performance.now() - startTime;
                addResult(`üéµ SoundFont playable after ${(playableTime / 1000).toFixed(1)}s`, 'pass');

                // Phase 4: Sample data (background)
                updateProgress(70, 'Loading sample data in background...');
                const sampleDataTime = Math.min(sizeMB * 5, 3000);
                await new Promise(resolve => setTimeout(resolve, sampleDataTime));

                const totalTime = performance.now() - startTime;

                updateProgress(100, 'Progressive loading completed!');

                // Update results
                document.getElementById('progressive-time').textContent = `${(playableTime / 1000).toFixed(1)}s*`;
                document.getElementById('progressive-memory').textContent = `${(sizeMB * 1.2).toFixed(0)}MB`;
                
                const successRate = sizeMB < 600 ? 85 : sizeMB < 800 ? 80 : 65;
                document.getElementById('progressive-success').textContent = `${successRate}%`;
                
                const rating = successRate > 80 ? '‚úÖ Good' : successRate > 70 ? '‚ö†Ô∏è OK' : '‚ùå Poor';
                document.getElementById('progressive-rating').textContent = rating;

                addResult(`‚úÖ Progressive loading: playable in ${(playableTime / 1000).toFixed(1)}s, complete in ${(totalTime / 1000).toFixed(1)}s`, 'pass');
                addLog(`Progressive: ${(playableTime / 1000).toFixed(1)}s to playable, ${(totalTime / 1000).toFixed(1)}s total`);

            } catch (error) {
                addResult(`‚ùå Progressive loading failed: ${error.message}`, 'fail');
                addLog(`Progressive loading error: ${error.message}`);
                
                document.getElementById('progressive-time').textContent = 'Failed';
                document.getElementById('progressive-success').textContent = '0%';
                document.getElementById('progressive-rating').textContent = '‚ùå Fail';
            }

            showProgress(false);
        }

        async function testLazySampleLoading() {
            if (!selectedFile) return;

            addResult('üîÑ Testing Lazy Sample Loading...', 'info');
            showProgress();

            const startTime = performance.now();

            try {
                const sizeMB = selectedFile.size / (1024 * 1024);

                // Load only metadata (~30% of file)
                updateProgress(20, 'Loading SoundFont metadata...');
                const metadataTime = Math.min(sizeMB * 1.5, 1000);
                await new Promise(resolve => setTimeout(resolve, metadataTime));

                updateProgress(60, 'Setting up sample loading system...');
                await new Promise(resolve => setTimeout(resolve, 200));

                updateProgress(90, 'Ready for on-demand sample loading...');
                await new Promise(resolve => setTimeout(resolve, 100));

                const totalTime = performance.now() - startTime;
                const memoryUsage = sizeMB * 0.3 + 50; // Metadata + overhead

                updateProgress(100, 'Lazy loading system ready!');

                // Update results
                document.getElementById('lazy-time').textContent = `${(totalTime / 1000).toFixed(1)}s`;
                document.getElementById('lazy-memory').textContent = `${memoryUsage.toFixed(0)}MB`;
                
                const successRate = sizeMB < 1000 ? 95 : sizeMB < 2000 ? 90 : 80;
                document.getElementById('lazy-success').textContent = `${successRate}%`;
                
                const rating = successRate > 90 ? '‚úÖ Great' : successRate > 80 ? '‚úÖ Good' : '‚ö†Ô∏è OK';
                document.getElementById('lazy-rating').textContent = rating;

                addResult(`‚úÖ Lazy loading ready in ${(totalTime / 1000).toFixed(1)}s (samples load on-demand)`, 'pass');
                addResult(`üí° Memory usage: ${memoryUsage.toFixed(0)}MB (${((memoryUsage / (sizeMB * 1.5)) * 100).toFixed(0)}% of sequential)`, 'info');
                addLog(`Lazy: ${(totalTime / 1000).toFixed(1)}s ready time, ${memoryUsage.toFixed(0)}MB memory`);

            } catch (error) {
                addResult(`‚ùå Lazy loading failed: ${error.message}`, 'fail');
                addLog(`Lazy loading error: ${error.message}`);
                
                document.getElementById('lazy-time').textContent = 'Failed';
                document.getElementById('lazy-success').textContent = '0%';
                document.getElementById('lazy-rating').textContent = '‚ùå Fail';
            }

            showProgress(false);
        }

        async function testAllStrategies() {
            if (!selectedFile) return;

            addResult('üöÄ Testing all loading strategies...', 'info');
            clearResults();
            
            await testSequentialLoading();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testStreamingLoading();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testProgressiveLoading();
            await new Promise(resolve => setTimeout(resolve, 500));
            
            await testLazySampleLoading();

            // Summary
            addResult('üìä All strategies tested! Check the results table above.', 'info');
            
            const sizeMB = selectedFile.size / (1024 * 1024);
            if (sizeMB > 500) {
                addResult('üí° Recommendation: Use lazy sample loading for this large file', 'info');
            } else if (sizeMB > 100) {
                addResult('üí° Recommendation: Progressive loading offers good balance', 'info');
            } else {
                addResult('üí° Recommendation: Sequential loading is sufficient for this file size', 'info');
            }
        }

        // File drop zone handling
        const dropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('soundfont-file');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('dragover');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('dragover');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFileSelect(files[0]);
            }
        });

        dropZone.addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileSelect(e.target.files[0]);
            }
        });

        // Button event handlers
        document.getElementById('test-sequential').addEventListener('click', testSequentialLoading);
        document.getElementById('test-streaming').addEventListener('click', testStreamingLoading);
        document.getElementById('test-progressive').addEventListener('click', testProgressiveLoading);
        document.getElementById('test-lazy').addEventListener('click', testLazySampleLoading);
        document.getElementById('test-all-strategies').addEventListener('click', testAllStrategies);

        // Initialize
        addLog('Large SoundFont loading test page initialized');
        addLog('Drop a .sf2 file or use the browse button to begin testing');
    </script>
</body>
</html>